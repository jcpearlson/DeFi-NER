Nakamoto’s famous blockchain protocol enables achieving consensus in a so-called permissionless setting—anyone can join (or leave) the protocol execution, and the protocol instructions do not depend on the identities of the players.
His ingenious protocol prevents “sybil attacks” (where an adversary spawns any number of new players) by relying on computational puzzles (a.k.a.
“moderately hard functions”) introduced by Dwork and Naor (Crypto’92).
The analysis of the blockchain consensus protocol (a.k.a.
Nakamoto consensus) has been a notoriously difficult task.
Prior works that analyze it either make the simplifying assumption that network channels are fully synchronous (i.e.
messages are instantly delivered without delays) (Garay et al, Eurocrypt’15) or only consider specific attacks (Nakamoto’08; Sampolinsky and Zohar, FinancialCrypt’15); additionally, as far as we know, none of them deal with players joining or leaving the protocol.
In this work we prove that the blockchain consensus mechanism satisfies a strong forms of consistency and liveness in an asynchronous network with adversarial delays that are a-priori bounded, within a formal model allowing for adaptive corruption and spawning of new players, assuming that the computational puzzle is modeled as a random oracle.
(We complement this result by showing a simple attack against the blockchain protocol in a fully asynchronous setting, showing that the puzzle-hardness needs to be appropriately set as a function of the maximum network delay; this attack applies even for static corruption.) As an independent contribution, we define an abstract notion of a blockchain protocol and identify appropriate security properties of such protocols; we prove that Nakamoto’s blockchain protocol satisfies them and that these properties are sufficient for typical applications; we hope that this abstraction may simplify further applications of blockchains.
Distributed systems have been historically analyzed in a closed setting in which both the number of participants in the system, as well as their identities, are common knowledge.
A departure from this model started with the design of peer-to-peer systems, e.g.
with systems such as Napster and Gnutella for file sharing.
The success of those systems led to academically designed systems such as Freenet [CSWH00], CAN [RFH+ 00], Chord [SMK+ 01], and Pastry [DR01] which offered redundant file storage, distributed hashing, selection of nearby servers, and hierarchical naming.
A novel aspect of these peer systems is that they are permissionless— anyone can join (or leave) the protocol execution (without getting permission from a centralized or distributed authority), and the protocol instructions do not depend on the identities of the players.
As participants may continuously join and leave the system, successful permissionless systems require a fault-tolerant design.
Unfortunately, the mentioned systems, while “robust” with respect to measures such as connectivity [DLN02], were not designed to tolerate against adversarial behavior.
For example, there were no guarantee that one participant’s experience with the system was consistent with another’s: Two participants requesting the same file may end up receiving different versions and never know that they did.
At first sight one may think that using standard consensus/Byzantine agreement methods (e.g., [CL99, MA05, Lam10, Lam11]) could help overcome this issue.
The problem is that such protocols require that a large fraction of the participating players are honest, but in the permissionless setting an attacker can trivially mount a so-called “sybil attack”—it simply spawns lots of players (that it controls) and can thus easily ensure that it controls a majority of all the players.
Indeed, Barak et al [BCL+ 05] proved that this is a fundemental problem with the permissionless model.
Nakamoto’s Blockchain In 2008, Nakamoto [Nak08] proposed his celebrated “blockchain protocol” which overcomes the above-mentioned problems by relying on the idea of computational puzzles—a.k.a.
moderately hard functions or proofs of work —put forth by Dwork and Naor [DN92].
Rather than attempting to provide robustness whenever the majority of the participants are honest (since participants can be easily spawned in the permissionless setting), it attempts to provide robustness as long as a majority of the computing power is held by honest participants.
It explicitly claims consistency properties that are strong enough to support a financial transaction system; indeed, the first application of a blockchain is the Bitcoin digital currency which needs strong properties to prevent fraud and double-spending attacks.
A number of follow-up digital currencies [Lit], micro-payment schemes [PS15, PD15], time-stamping [BTP], naming [Nam], fair secure computation [BK14] and secure messaging and PKI applications [FVY14] are based on the blockchain idea.
Additionally, financial firms have announced intentions of using the blockchain to lower transaction costs, remove geopolitical barriers to transferring assets, and reconcile differences between systems.
The core blockchain protocol (a.k.a.
“Nakamoto consensus”, or the “Bare-bones blockchain protocol”), roughly speaking, is a method for maintaining a public, immutable and ordered ledger of records (for instance, in the bitcoin application, these records are simply transactions); that is, records can be added to the end of the ledger at any time (but only to the end of it); additionally, we are guaranteed that records previously added cannot be removed or reordered and that all honest users have a consistent view of the ledger.
While standard consensus/Byzantine agreement mechanisms could be used to achieve such an immutable ordered sequence of records, the amazing aspect of Nakamoto’s consensus mechanism is that it functions in a fully permissionless setting.
Roughly speaking, in his protocol each participant maintains its own local “chain” of “blocks” of records/messages—called the blockchain.
Each block consist of a triple (h−1 , η, m) where h−1 is a pointer to the previous block in chain, m is the record component of the block, and η is a “proof-of-work”—a solution to a computational puzzle that is derived from the pair (h−1 , m).
Theproof of work can be thought of as a “key-less digital signature” on the whole blockchain up until this point.
Concretely, Nakamoto’s protocol is parametrized by a parameter p—which we refer to as the mining hardness parameter, and a proof-of-work is deemed valid if η is a string such that H(h−1 , η, m) < Dp , where H is a hash function (modeled as a random oracle) and Dp is set so that the probability that an input satisfies the relation is less than p.
(In practice, the hardness parameter p is adaptively modified through some external process to incorporate an estimate of the number of participants in the system and the network delays; we shall return to the choice of p later.) At any point of the protocol execution, each participant attempts to increase the length of its own chain by “mining” for a new block: upon receiving some record m, it picks a random η and checks whether η is a valid proof of work w.r.t.
m and h−1 , where h−1 is a pointer to the last block of its current chain; if so, it extends is own local chain and broadcast it to the all the other participants (the broadcast takes places through some gossip protocol, which we do not discuss here).
Whenever a participant receives a chain that is longer than its own local chain, it replaces its own chain with the longer one.
The fundamental question with such an approach is whether honest participants eventually end up with the same longest chain of blocks, and thus, the same ordered list of records, or whether the system devolves into a state where participants have inconsistent local chains.
Requiring that all participant agree on the whole chain is a too strong consistency requirement if the protocol is executed on a network with message delays (as Nakamoto’s protocol is intended to be)—for instance, some players may have received the “last block” whereas other have not.
Rather, as discussed by Nakamoto [Nak08], the appropriate notion of consistency for the blockchain—which we refer to as T -consistency—should require that honest players agree on the current chain, except for potentially a small number, T , of “unconfirmed” blocks at the end of the chain.
If we can show this property holds except with exponentially small probability in T , honest parties are guaranteed that for a sufficiently large choice of T (except with tiny probability), “confirmed” blocks will never be lost from the chain (which is what is needed for all the above-mentioned applications; for instance, for the case of bitcoin, it ensures that players cannot double-spend money).
Nakamoto provides an initial analysis of consistency assuming that the adversary only mounts a particular attack strategy (namely, an attacker tries to generate a chain faster than the honest players); for instance, his analysis does not consider more sophisticated attack strategies where the adversary may attempt to “split the players” and have them work on different chains.
A beautiful recent work by Garay, Kiayas and Leonardos [GKL15] provides a more formal model for studying Nakamoto’s blockchain protocol; their analysis, however, only considers a synchronous network with a rushing adversary—that is, messages sent in a particular round arrive in the next round without any delays, but the adversary gets to see all messages sent by honest parties before having to send its own message.
In this model, they demonstrate that the blockchain protocol satisfies consistency (under appropriate assumptions on the mining hardness and the relative computational power held by the attacker), in a setting with a fixed number of players (but the protocol is not aware of the exact number of players).
Assuming a synchronous network, however, is a very strong, possibly unrealistic assumption; indeed, Nakamoto’s protocol is explicitly designed to work in a network with message delays, and indeed is executed on such a network (i.e., the Internet).
The Power of Network Delays Consequently, we are here interested in analyzing to what extent the blockchain protocol satisfies consistency in the more realistic setting of an asynchronous network, where an adversary controls the scheduling/delivery of messages between honest parties.
As we observe (and formally prove in Theorem 8.1), in a fully asynchronous setting, where an adversary can arbitrarily delay messages, consistency cannot be satisfied: an adversary controlling a small percentage of the computational power can simply delay messages from honest parties for sufficiently long to ensure that the adversary can come up with its own chain (containing any set of records it desires) which is longer than the chain held by all honest players, and consequently it can make the honest players switch to the adversarial chain at any point.
In fact, our attack works even in the setting of partial synchrony (see e.g.
[DLS88]) where there is an a-priori bound ∆ on the network latency (that is, the adversary may arbitrary delay messages as long as it delivers them within time ∆), as long as the mining hardness parameter p exceeds ρn∆ , where ρ is the fraction of the computational power held by the adversary and n is the number of players (and p is the mining-hardness parameter in Nakamoto’s protocol).
Indeed, Decker and Wattenhofer [DW13] already experimentally observed that increasing the networks delays in Nakamoto’s protocol leads to increased forks, and they noted (through heuristic calculations) that an attacker could use these delays to violate consistency with an attack that requires less than 50% of the mining power.
Motivated by the work by Decker and Wattenhofer, an elegant work by Sompolinsky and Zohar [SZ15] provides some initial analysis of the blockchain protocol even in a network with (bounded) delays.
They show how to extend Nakamoto’s analysis to deal with (bounded) delays, but again (just like Nakamoto) they only consider particular attack strategies—e.g., they do not consider “block-withholding (or “pre-mining”) attacks” where the attacker withholds blocks for later use [mtg10, ES14]; furthermore, their analysis only shows that consistency holds in the limit (when T goes to infinity), and consequently their bounds (even for the restricted attacker setting) are not useful for applications.
This leaves open the question of providing an analysis of Nakamoto’s blockchain protocol— or in fact any consensus protocol in the permissionless setting—with respect to arbitrary attack strategies in networks with ∆-bounded delays.
Does Nakamoto’s blockchain protocol satisfy consistency when executed in asynchronous networks with ∆-bounded delays? As mentioned above, Garay et al [GKL15] provide a positive answer for the special case when ∆ = 1 (i.e., messages are delivered in the next time step1 ), and Sampolinsky and Zohar [SZ15] show that certain (natural, but restricted) strategies cannot be employed to break consistency of Nakamoto’s protocol (in the limit) in ∆-bounded delay networks.
Let us highlight why dealing with network delays in the “proof-of-work” setting (where we assume that a majority of the computing power is honest) is significantly more challenging than in the “standard” permissioned setting: In the standard model, any synchronous protocol can be turned into a protocol that is secure also in ∆-delay networks by simply requiring all honest players to always “wait” (without doing anything) for ∆ time steps before responding to any message, effectively emulating synchronous rounds.
This approach completely fails in the proof-ofwork setting—the adversary can now increase its computational resources by a factor ∆ (since it can try to solve puzzle when the honest players are “waiting”).
1.2  Main Results  In this paper, we resolve the above-mentioned problem and demonstrate that (assuming puzzles are modeled as random oracles) Nakamoto’s protocol satisfies consistency (under appropriate assumptions on the mining hardness and the relative computational power held by the attacker) alsoin networks with message delays.
We emphasize that our analysis is not just a combination of the techniques/ideas from [GKL15] and [SZ15]—in fact, the bulk of our proof consists of dealing with the attack strategies which are omitted from the analysis in [SZ15], and dealing with them requires us to consider an altogether different proof technique.
Additionally, our analysis considers adaptive corruption and spawning of new players (i.e., new players joining); as far as we know, it is the first analysis to formally deal with spawning of new players (which is a cruical desidrata of the blockchain protocol).
A Consistency Theorem with Delays We provide a rough overview of our model and consistency theorem.
Consider Nakamoto’s protocol with mining-hardness p (that is, a single random oracle query is a successful “in mining” with probability p), and consider an execution with n players, each of them with identical computing power—we assume the protocol proceeds in rounds (timesteps), and in each round each player gets a single random oracle query and the adversary controlling a ρ fraction of the players gets ρn random oracles queries (as in [GKL15], the honest players need to make their queries in parallel, but we allow the adversary to makes the queries sequentially).
1.3  What is a Blockchain?  As an independent contribution, we formally define an abstract notion of a blockchain (as opposed to the blockchain protocol proposed by Nakamoto) and put forward desired security properties of such a blockchain.
We believe that having such a notion will a) simplify applications of blockchains (as we can ignore the implementation details of the blockchain protocol) and b) enable formally studying to what extent the protocol can be improved.
(As we explain below, both of these points have been illustrated in subsequent works [PS16a, PS16b].) We mention that while abstract models for higher-level applications of the blockchain (e.g., a “smart contract” abstraction) were provided in the UC framework—see [KMS+ 15, BK14]—it is not clear to what extent those abstractions can be satisfied by Nakamoto’s protocol; rather, we are here interested in having a simple notion of the blockchain itself that we can prove is satisfied by Nakamoto’s protocol and yet is useful for applications.
Roughly speaking, a blockchain is an interactive protocol where each participant has a local variable state which contains a list of messages m, ~ called the “chain”.
Players receive inputs, called records/batches/messages, that they attempt to include in the chain of themselves and of others.
We require the following properties from a secure blockchain: • consistency: with overwhelming probability (in T ), at any point, the chains of two honest players can differ only in the last T blocks; • future self-consistence: with overwhelming probability (in T ), at any two points r, s the chains of any honest player at r and s differ only within the last T blocks; • g-chain-growth: with overwhelming probability (in T ), at any point in the execution, the chain of honest players grows by at least T messages in the last Tg rounds; g is called the chain-growth of the protocol.
• the µ-chain quality with overwhelming probability (in T ), for any T consecutive messages in any chain held by some honest player, the fraction of messages that were “contributed by honest players” is at least µ.
The consistency property is just the “plain” one considered already by Nakamoto [Nak08] (and formalized by Garay et al [GKL15]).
As we note, however, this consistency property is typically not sufficient for applications.
Clearly such a protocol does not suffice for typical applications (e.g., bitcoin, or achieving a public ledger).
Thus, to prevent it, we introduce the future self-consistency property.
The lower bound on chain-growth was explicitly considered by Sampolinsky and Zohar [SZ15] (but they only consider growth in expectation); Garay et al [GKL15] implicitly show a lower-bound on on chain growth within one of their proofs, and [KP15] explicitly introduce it as a desideratum.
In this paper, we additionally introduce an upper-bound on chain growth as a desirable property; as shown in subsequent work [PS16a, PS16b], this property is useful in applications.
Finally, the chain quality property was first discussed on the Bitcoin forum [mtg10] and made explicit in the selfish mining attacks by Eyal and Sirer [ES14] w.r.t.
the bitcoin application of the blockchain.2 The property was first formalized, and given the name “chain quality” by Garay et al [GKL15]; Garay et al [GKL15] furthermore show new applications of it (as we discuss shortly).
We show the usefulness of these properties by demonstrating that any blockchain protocol satisfying them can be used to achieve a public ledger (i.e., consensus) satisfying a) persistency (namely, if a message gets added to the public ledger, it never gets removed) and b) liveness (that is, if all honest players want to add a some message to the ledger, the message should eventually appear on it).
We mention that Garay et al [GKL15] already noted that, intuitively, the chain quality property implies liveness (since, by chain quality the adversary cannot monopolize the chain), and consistency implies persistence.
However, although they show how to use Nakamoto’s protocol to obtain a public ledger (in the synchronous model), they use those two properties and additional properties of the concrete protocol to establish it.
Kiayias and Panagiotakos [KP15] demonstrate that by additionally requiring chain growth suffices to prove liveness in a black-box way, but proving persistence still required an analysis of the concrete protocol.
We highlight that it is our notion of future-self consistency that allows us to obtain also persistence in a black-box way.
Subsequent works by Pass and Shi [PS16a, PS16b] give further evidence to the usefulness of our abstract notion of a blockchain (and its security properties).
Thus, as long as ρ < 12 , Nakamoto’s protocol guarantees that messages contributed by honest players will eventually end up on the chain, and as long as ρ < 13 , we have that half of the messages on the chain will be contributed by honest players.
We mention that our chain quality bound matches that established by Garay et al [GKL15] assuming no delays (i.e., ∆ = 1), and is tight due to the selfish mining (a.k.a.
“mining-cartel”) attacks of [mtg10, ES14]).
A natural question left open by our main theorem is whether there exists protocols satisfying our abstract notion of a blockchain that improve upon the parameters achieved by Nakamoto’s protocol (i.e., is Nakamoto’s protocol “optimal”?).
A subsequent result by Pass and Shi [PS16a] shows how we can “amplify” the chain quality in Nakamoto’s protocol to achieve a “close-to-optimal” chain quality of 1 − (1 − δ)ρ, where δ is an arbitrary small constant.3 We highlight that the results in [PS16a] relies on the analysis from this paper in a blackbox way.
1.4  Is Nakamoto’s Protocol Really Permissionless?  Our theorem only shows that for every n, ∆, there exists some mining-hardness parameter p that makes the protocol secure, so it might seem like the protocol needs to know n and therefore cannot be “permissionless”; see Section 1.5 for an experimental evaluation of how the level of security depends on the choice of p.
(As we pointed out above, this is not an anomaly of our analysis; when 1 p > nρ∆ the protocol is insecure.) The point, however, is that the protocol only needs to know a very rough upper-bound on the number of players n (but the worse the upper-bound gets, the worse the efficiency of the protocol becomes.) We additionally remark that our theorem regarding the lower bound on the chain growth actually does not make any assumption about p; this means that the honest players can use an initial set-up phase to estimate the chain growth and from this deduce a weak upper-bound on the number of players n, and then use this new upperbound to run the protocol.
Indeed, as we hinted to before, the bitcoin protocol recalibrates the mining hardness parameter p every 2016 blocks (roughly 2 weeks) based on the time it took to find 2016 blocks.
We leave a formal analysis of this update procedure for future work.
1.5  An Experimental Interpretation  In this section, we provide an experimental interpretation of our theorems by using estimates of parameters in a real world setting.
In early 2016, the Bitcoin network collectively performed roughly 1018 hash operations per second [Blo16].
Several companies sell mining hardware that operates at 1012 hash operations per second.
To be consistent with these values, we consider n = 105 participants and ∆ = 1013 , which corresponds to roughly 10s delay for the network at the given hashing rates.
The 10s estimation is based on an assumption that most of the computational power contributing to the Bitcoin network operates with a connection that exceeds 1mb/s, thus, each block takes roughly 1s to transmit, and the diameter of the network is less than 10 hops.
These assumptions align with the empirical measurements made by Decker and Wattenhofer [DW13].
For a period during the summer of 2012, they computed the average blocktime to be roughly 10.55m and the “weighted average” ∆ ∼ 11.37s (their model realistically allows for ∆ to be a distribution with a long tail).
Their measurements are supported by website bitcoinstats.com for 2016.
However, in both cases, they measure connectivity by number of nodes instead of by computational resources; thus their “95th percentile” estimations are biased larger because they include many hobby nodes which are connected by slow network connections and do not contribute any noticeable computation to the protocol.
The hardness parameter in Nakamoto’s protocol reflects the expected time between the discovery of blocks among all participants.
Here, we can explore how consistency is related to this parameter by changing c.
One can interpret c as the scale-free expected block-time expressed in terms of the number of networks delays.
1 depicts when our consistency theorm holds in Nakamoto’s protocol by graphing c against the fraction (ρ) of computation controlled by the adversary.
The blue graph depicts a numerically-computed maximum value of ρ for which α(1−(2∆+2)α) > β, i.e.
parameters under which our theorem 4.3 shows consistency of the Nakamoto protocol.
The red plot shows when our best attack succeeds in violating consistency.
Nakamoto’s protocol attempts to maintain a 10-minute blocktime by varying hardness p.
For a delay ∆ ∼ 10s, this corresponds to a setting of c = 60.
In this range, the Nakamoto protocol, as well as our attack give essentially the same result: Nakamoto tolerates an adversary with ρ < 49.57%and our best attack succeeds when ρ > 49.79%.
If we make a very conservative estimate of network delays being 1m, then c = 10, and Nakamoto remains consistent with respect to a 47.2% coalition.
Finally, let us remark that the reason that our analysis is not tight when c is small is that in our attack we only consider the probability that the adversary is able to completely control the chain.
When c is small, there is also a large probability that honest players do not converge on a chain even without any adversarial messages.
1.6  Proof Highlights  Although our high-level approach follows similar intuitions as the analyses from Garay et al [GKL15] and Sompolinsky and Zohar [SZ15], our actual proof uses a quite different proof strategy.
As mentioned, the bulk of our proof consists of dealing with the attack strategies which are omitted from the analysis in [SZ15], and dealing with them requires us to consider an altogether different proof technique: instead of directly analyzing the whole blockchain process, we consider a sequence of simplified processes which are “dominated” by the original one but are simpler to analyze.
For instance, we aim to show that in the optimal attack, the adversary should always delay messages for as long as possible (so that messages are always delivered after ∆ steps).
An obstacle in performing such a stochastic domination analysis is that once we start delaying messages, honest parties start to “mine” different blocks and the executions of our two processes diverge and become hard to compare: Ideally, to perform the domination argument we would like to consider a fixed execution (where the randomness of all parties are fixed) and to show by induction delaying messages less than ∆ never helps the attacker in that particular execution.
The problem is that such a domination claim is not true: one can come up with scenarios (where the randomness is fixed) where, “by luck” delaying messages improves things for the honest parties (they now start mining blocks that magically lead to more successes).
Of course, the probability of this happening should be small, but formally showing this would require us to somehow couple the experiments with and without maximum delays which is non-trivial (due to dependencies created by the random oracle) The Ftree model.
To overcome this issue, we rely on “simulation techniques” from the cryptographic literature on secure computation [GMW87, Can00]: we first consider an idealized scenario where the players do not mine blocks but instead have access to an idealized “mining” functionality, which we call Ftree .
This functionality determines whether honest parties succeed in mining (at random) and the success probability is independent of the current chain an honest party is trying to extend.
In this model, we can now perform a domination argument for every fixed randomness for the experiment.
One of our main technical lemmas, which turns out to be quite subtle to prove, shows that any attack that succeeds in the “real-life” protocol in the random oracle model can be turned into (i.e., simulated by) an attack in the idealized Ftree model.
The key technical issue here is to deal with the dependencies created by the random oracle.
(As an independent contribution, we believe that our Ftree simulation lemma can be helpful in formalizing some steps left informal in e.g., [GKL15, KP15, SZ15].) The chain growth lowerbound.
Armed with the above-mentioned techniques, the next crucial step is demonstrating a lowerbound on the chain growth.
Roughly speaking, we prove by induction that (in the Ftree model) the chain grows at least as fast in the real execution of the protocol, as in a “hybrid” experiment where a) all messages are maximally delayed, b) honest parties “freeze” and stop mining for ∆ steps whenever some honest player mines a block and c) all messages sent by the adversary are removed.
The advantage of this hybrid experiment is that the chain growth process can now be described as a simple Markov chain—there are no longer any “adversarial transitions” and due to the “freezing”, honest players never have any chain conflict.
This process can next beanalyzed using standard Chernoff bounds.
We emphasize that for the induction proof to go through, we cruicially rely on the fact that our analysis is in the Ftree -model.
We next use the chain growth lowerbound to demonstrate a central property of the blockchain protocol, which we refer to as the “no long block withholding” property : an adversary cannot “withhold” a block that it has mined for too “long”—unless it broadcasts the block to the honest players within some short amount of time, the block becomes “irrelevant” and will never be accepted by the honest players.
Roughly speaking, we prove this by showing that, assuming that the adversary controls less than half of the computational power in the network, the chain of honest players will grow at a faster rate than any private chain the adversary can create, and thus unless it releases any block it finds quickly, the honest players’ chain will be too long for the block to ever be relevant.
Finally, proving consistency is the most challenging part of our proof.
We start by first considering an execution without adversarial messages, and with deterministic delays, and identify a “pattern” which ensures that the chain of honest players converges: roughly, the pattern—which we refer to as a “convergence opportunity”—is that 1) there is a period of “silence” for ∆ rounds where no honest player mines a block, 2) this is followed by a round where a single honest player mines a block, 3) which is followed by another ∆ rounds of silence.
Note that whenever such a pattern occurs, at the end of it all honest players have converged on the chain (which is why we call it a convergence opportunity): after the first period of silence, they all agree on the length of the chain (but may still have different chains), and thus the lone miner who finds a new block extends this longest chain by 1, and finally after the second period of silence this chain has propagated to all honest players (and since it is longer than all their current chains, they will switch to it).
We are now interested in understanding how many such patterns happen within some specific period of time t.
The cruicial points here is that the process we now are analyzing is memoryless, and thus can be described by a (somewhat simple) Markov chain.
On the negative side, the Markov chain that arises from this problem is too complicated to be analyzed with standard concentration bounds for Markov chains (see e.g., [CLLM12]); we instead, provide a direct analysis of a simplified experiment (which, roughly speaking, instead analyzes the times between successful mining of honest players.) and we then use this to provide a lowerbound on the number of convergence opportunities.
Finally, once we have established a strong concentration bound on the number of occurrences of such convergence opportunities, we argue that the only way that an attacker can “ruin” such a pattern is by itself mining a block that is accepted by the honest players during it.
We here rely on the block-withholding lemma to argue that any block that the attacker can use to ruin a convergence opportunity must have been mined by the adversary not long before the beginning of the period of time we are analyzing; we then show that the number of adversarial block mined during this (slightly extended) period of time is smaller than the number of “convergence opportunities”, and thus conclude that at least one convergence opportunity will remain even in the presence of the adversary, and thus honest parties still converge on their chain.
The problem of reaching agreement in the presence of faulty participants, described first by Pease, Shostak, and Lamport [PSL80], and also known as distributed consensus has been very well studied over the past 40 years.
The basic problem considers a set of n parties connected by reliable and authenticated pairwise network channels who wish to agree on a common output in the presence of an adversary who controls a fraction of the participants.
Many aspects of the problem have been studied, with relaxations concerning the fraction of corrupted parties, the channels availableto the participants, whether the protocols are deterministic or randomized and whether the participants are computationally bounded.
Some protocols only consider fail-stop adversaries, while others consider a Byzantine setting in which some of the participants are malicious adversaries who attempt to disrupt the agreement.
In the Byzantine agreement (BA) version of the problem, Castro and Liskov [CL99] implemented a replication library that was practical enough to use for a file system; subsequently, other works have considered “fast” or ”simpler” versions of the Paxos protocol [MA05, Lam10, Lam11].
All of these works assume, however, common knowledge of the number of participants n, as well as identities for the participants.
Okun [Oku05a, Oku05b, OB08] considers BA in an “anonymous [synchronous] model without port awareness” in which processors do not have identifiers and cannot correlate messages to their sources; Okun shows both an impossibility result for deterministic protocols, and a feasibility result for probabilistic ones.
[AJK05] shows how using a proof-of-work in a pre-processing step for this model can be used to assign interim identities to parties so that the number of identities assigned was proportional to computational power.
After the pre-processing, a standard authenticated BA protocol is used.
Neither results, however, are in the peer-to-peer setting in which new users can join and leave during the execution.
Miller and LaViola [ML14] show that variant of Nakamoto’s protocol can be used to solve the single-shot Byzantine agreement problem in the presence of a minority of faults in an asynchronous setting.
The single-shot setting is substantially easier, since the adversary is limited, and for example, cannot mount block-withholding attacks.
Garay, Kiayias, and Leonardas [GKL15] provide a better analysis of Nakamoto’s protocol, and also propose two protocols based on Nakamoto’s protocol that satisfy all the properties of BA in the multiple-instance setting.
They only consider synchronous networks (and no spawning of new honest players).
(As mentioned above, however, in synchronous networks, simpler solutions are possible.)   A blockchain protocol is a pair of algorithms (Π, C) where Π is a stateful algorithm that receives a security parameter κ as inputs and maintains a local state state.
The algorithm C(κ, state) outputs ~ (e.g., in the bitcoin protocol, each such record is an ordered sequence of “records”, or “batches”, m an ordered sequence of transactions).
We call C(κ, state) the “record chain” of a player with security parameter κ and local variable state; to simplify notation, whenever κ is clear from context we often write C(state) to denote C(κ, state).
Algorithm Π is parameterized by a validity predicate V (denoted by ΠV ) that encapsulates the semantic properties (e.g., “no double spending”) that a blockchain application aims to achieve.
~ is valid for some notion of validity.
V (~ m) returns 1 if and only if the chain m A Blockchain Execution Following the framework for Universal Composability [Can00], we consider the execution of a blockchain protocol (ΠV , C) that is directed by an environment Z(1κ ) (where κ is a security parameter), which activates a number of parties 1, 2, .
, n as either “honest” or corrupted parties.
Honest parties execute Π on input 1κ with an empy local state state; corrupt parties are controlled by an attacker A which reads all their inputs/message and sets their outputs/messages to be sent.
• The execution proceeds in rounds that model time steps.
In round r, each honest player i receives a message (a “record”) m from Z (that it attempts to “add” to its chain) and potentially receives incoming network messages (delivered by A).
It may then perform any computation, broadcast a message to all other players (which will be delivered by the adversary; see below) and update its local state statei .
• A is responsible for delivering all messages sent by parties (honest or corrupted) to all other parties.
A cannot modify the content of messages broadcast by honest players, but it may delay or reorder the delivery of a message as long as it eventually delivers all messages.
(Later, we shall consider restrictions on the delivery time.) The identity of the sender is not known to the recipient.4 • At any point, Z can communicate with adversary A or access C(statei ) where statei is the local state of player i.
• At any point, Z can corrupt an honest party j which means that A gets access to its local state and subsequently, A controls party j.
(In particular, this means we consider a model with “erasures”; random coin tosses that are no longer stored in the local state of j are not visible to A.)5 • At any point, Z can uncorrupt a corrupted player j, which means that A no longer controls j and instead player j starts executing Π(1κ ) with a fresh state statej .
(This is also how we model Z spawning a “new” honest player.) A gets informed of all such uncorrupt messages and is required to deliver all messages previously sent by (currently alive) honest players.6 V  Let EXEC(Π ,C) (A, Z, κ) be a random variable denoting the joint view of all parties (i.e., all their inputs, random coins and messages received, including those from the random oracle) in the above execution; note that this joint view fully determines the execution.
Admissible Environments We will be considering executions with restricted adversaries and environments; these restrictions will be specified by a predicate Γ(·, ·, ·, ·).
We could also consider a seemingly weaker model where messages sent by corrupted parties need not be delivered to all honest players.
We can easily convert the weaker model to the stronger model by having honest parties “gossip” all messages they receive.
5 Our proof actually extends also to the model “without erasures”.
6 This models the fact that a player is not considered “honest” before it has joined the network and gotten “initialized”.
In the real-life execution of bitcoin, new players joining send out a message to the network, request to be initialized and download the longest chain known to the network.
We only consider them honest once this process is over.
Our model assumed that any player can send a message to all other players in the network, and that those messages arrive within ∆ rounds, no matter how long they are.
This is clearly not a very realistic model.
In real-life, player communicate their messages through a gossip network, and thus we need to assume that this network is sufficiently connected and has sufficiently many honest players to ensure ∆ delivery time.
This still clearly is infeasible if messages can be arbitrary long.
However, in the applications we consider—assuming that records m provided by the environment are of length O(κ) (i.e., there is a “block-size limit”7 )—honest players only communicate messages that differ in the last O(κ) bits from messages that they have previously received.
For such cases it seems reasonable to assume that a sufficiently connected routing network has the desired property of ensuring delivery of all messages within ∆ rounds.
2.3  Blockchain protocols in the ROM  To model Nakamoto’s blockchain protocol, we need to extend the model with a random oracle.
In an execution with security parameter κ, we assume all parties have access to a random function H : {0, 1}∗ → {0, 1}κ which they can access through two oracles: H(x) simply outputs H(x) and H.ver(x, y) output 1 iff H(x) = y and 0 otherwise.
In any round r, the players (as well as A) may make any number of queries to H.ver.
On the other hand, in each round r, honest players can make only a single query to H, and an adversary A controlling q parties, can make q sequential queries to H.
(This modeling is meant to capture the assumption that we only “charge” for the effort of finding a solution to a “proof of work” [DN92], but checking the validity of a solution is cheap.
We discuss this further after introducing Nakamoto’s protocol.) We emphasize that the environment Z does not get direct access to the random oracle (but can instruct A to make queries).
• Read all incoming messages (delivered by A).
If any incoming message state0 is a valid sequence of blocks that is longer than its local state state, replace state by state0 .
(Note that checking the validity of state0 can be done using only H.ver queries) 7 In Bitcoin’s instantiation of the blockchain protocol, there is currently a severe restriction on the block-size.
There is currently an active debate whether to raise the block-size limit or to leave it small.
8 In reality (as well as in the description in the introduction), h is not included in the block (as it can be easily determined from the remaining elements); we include it to ensure that we can verify validity of a block using only H.ver.• Read local message m (from Z).
If m is such that V (C(state)||m) 6= 1, proceed to the next round.
Otherwise, pick a random nonce n ∈ {0, 1}κ and issue query h = H(h−1 , η, m) where h−1 is the 4’th element in the last block in state.
If h < Dp , then Π adds the newly mined block (h−1 , η, b, h) to state and broadcasts the updated state.
Depending on the definition of V , one can instantiate either Bitcoin, e.g., by having V enforce that m can be parsed into a sequence of well-formed transactions each of which is authorized and spends money from a source account to a destination account at most once without deficit, etc., as well as other cryptocurrencies with different semantics such as Namecoin.
We may also consider a simpler predicate VL that simply accepts all messages; that is VL (~ m) = 1; such a predicate is useful, for instance, to use a blockchain to provide a public ledger.
A Remark on our use of the Random Oracle Recall that in our model, we restrict players to a single evaluation query H per round, but allow them any number of verification queries H.ver in the same round.
We do this to model the fact that checking the validity of mined blocks is “cheap” whereas the mining process is expensive.
(To enable this, we have included a pointer h to the current record in every mined block in the description of Nakamoto; thus a player need not spend an H query to compute the pointer to the previous record.) In practice, the cost of evaluating a hash function (which is used to instantiate the random oracle) is the same as verifying its outputs, but our modeling attempts to capture the phenomena that a miner typically use various heuristics (such as black lists of IP addresses that have sent invalid blocks) and different hardware to check the validity of a mined block versus to mine a new block.
Our first desiderata is that the chain grows proportionally with the number of rounds of the protocol.
This intuitive property was explicitly considered by Sompolinsky and Zohar [SZ15] but they only consider growth in expectation; it was also implicitly considered in Garay et al [GKL15] within one of their proofs (but was not highlighted as a desideratum), and explicitly highlighted as a desideratum by Kiayias and Panagiotakos [KP15].
We here generalize these definitions to“abstract” blockchain protocols, and add a useful “length” consistency property.
(Looking forward, in Section 3.4, we will also consider an upper-bound on chain growth.) Let, min-chain-increaser,t (view) = min |Cjr+t (view)| − |Cir (view)| i,j  where we quantify over players i, j such that i is honest at viewr and j is honest at viewr+t .
Let growtht (view, ∆, T ) = 1 iff the following two properties hold.
In the bitcoin application of the blockchain, each player receives a reward whenever if mines a block; the chain quality thus dictates a bound on how much more reward an adversary can get by deviating from the protocol.
The common-prefix property by Garay et al [GKL15], which was already considered and studied by Nakamoto [Nak08], requires that in any round r, the record chains of any two honest players i, j agree on all, but potentially the last T , records.
We note that this property (even in combination with the other two desiderata) provides quite weak guarantees: even if any two honest parties perfectly agree on the chains, the chain could be completely different on, say, even rounds and odd rounds.
We here consider a stronger notion of consistency which additionally stipulates players should be consistent with their “future selves”.10  Chain Growth Upperbound  Our final desiderata is the existence of an upperbound on the chain growth.
While we do not present any applications of this property in the current paper, it is an intuitively useful property—for instance, combined with the chain growth lower bound, it implies we can use a blockchain as a “partially-synchronized clock”.
(Additionally, subsequent work by Pass and Shi [PS16a, PS16b] demonstrate the usefulness of this property.)  Pedantically, the “first ` records of Cjr (view) is not defined if Cjr (view) < `; to formalize it, we may represent the chains as infinite sequences of records, where all records after the end of the chain is a special “nil” symbol.
Our definitions of the above properties are quite strong in the sense that we require the probability of “bad” events happening to decrease exponentially with T , even for small T > c log κ.
A simpler definition of an abstract blockchain would require the above definitions to hold when T ≥ T0 (κ), where T0 is some polynomial, in this case, we may simply require that the probability of the bad event is neg(κ).
The reason we here distinguish between T and κ (and in particular, require the above definitions to hold when T is small) is that we aim to use the definitions to analyze Nakamoto’s specific blockchain protocol, and real-life instantiations of it typically consider quite different settings of values of κ and T ; for instance, in the Bitcoin application, we are interested in achieving T -consistency for T = 6 (i.e., transactions are only considered confirmed when they appear at depth 6 in the chain), but κ is typically 128.
We emphasize, however, that if our goal is to study optimal parameters (for e.g., consistency and chain quality), the more general notion seems more appropriate.
Our main results will be most convenient to parameterize in the following two quantities (which are defined for some fixed mining hardness function p(·); recall that Nakamoto’s protocol is parametrized by p):  Whenever κ, n, ρ, ∆ are clear from the context, we simply write α, β.
In essence, the quantities capture the per round expected “chain length increase” by the honest parties and the adversary; the reason the quantities are defined differently is that we assume that the adversary can sequentialize its queries in a round, whereas honest players make a single parallel query (they each act independently), and thus even if they manage to mine several blocks, the longest chain held by honest players can increase by at most 1.
Note, however, that when p is small (in comparison to 1/n), which is case for the Bitcoin protocol, α is well approximated by (1 − ρ)np and thus αβ ≈ 1−ρ ρ , so this difference is minor.
We will also consider the following quantity:  (Again, whenever κ, n, ρ, ∆ are clear from the context, we simply write γ.) Roughly speaking, γ should be thought of a “discounted” version of α due to the fact that messages sent by honest parties can be delayed by ∆ rounds and this may lead to honest players “redoing work”; γ corresponds to their “effective” mining power.
Note that if p is sufficiently small then γ ≈ α and thus βγ ≈ 1−ρ ρ .
We are now ready to state our main theorems.
We will consider two environments: The following three theorems formalize Theorem 1.2 from the introduction (which in turn implies Theorem 1.1).
We first prove a lower-bound on the chain growth.
p  Chain growth upperbound We additionally present an upperbound on the the chain growth.
(As mentioned before, this property is not needed for any of the applications that we present in the current paper, nor for the statement of the main result in the introduction, but may be useful in other contexts (and indeed, subsequent work [PS16a, PS16b] show its usefulness).)  The Ftree Hybrid Model  Towards proving that Nakamoto’s protocol satisfies the above properties, we first show that it suffices to prove these properties for a simplified protocol having access to an “idealized tree” functionality, Ftree , instead of a random oracle.
We now define a version of Nakamoto’s protocol (ΠpN ak , Cnak ) in the Ftree -hybrid model.
Essentially, this protocol replaces the random oracle with calls to Ftree .
state is initialized to just ⊥ (i.e., the genesis record).
Let Ctree (state) = state (i.e., the state of a player is now simply the sequence of records, as opposed to blocks).
Let Πptree be ΠpN ak with the exception that:  • When a player is trying to add a new record m to their current state state, instead of trying to “mine” it by picking a random nonce n etc, the player simply calls Tree.extend(state, m) and if it gets back the answer 1, it adds m to state and broadcasts (the whole updated chain) state.
• Upon receiving a message state0 from some other player, instead of checking whether it is “valid” using H.ver, simply check validity using Tree.ver(state0 ).
Whenever p is clear from context we simply denote the protocol (Πtree , Ctree ).
We now show that if our three desiderata hold w.r.t.
(Πtree , Ctree ), then they also hold w.r.t.
(ΠN ak , CN ak ).
In fact, we show something stronger: (ΠN ak , CN ak ) is as “secure as” (Πtree , Ctree ) w.r.t.
any property that is a function of the view of the environment (which is the case for the properties in our desiderata—more formally, for any g, µ, growth(view, g), quality(view, µ) and consistent(view) are only of function of the view of Z in view).
Let viewZ (view) denote the view of Z in the (full) view view.
In this section, we finally prove Theorems 4.1, 4.2 and 4.3.
By Lemma 5.1, it will suffice to prove them w.r.t.
We will heavily make use of the (multiplicative) Chernoff bound, which we recall in Appendix A.
Notation Although Nakamoto’s protocol in the Ftree hybrid model does not utilize the notion of a “block” or “mining”, for intuition, we still employ those terminologies with the following ~ ; such a block b is valid at some point in the execution interpretations.
A block b refers to a “path” m if b is a path (starting at the root) in the tree maintained by Ftree .
We say that a block b was mined at round r if in the view view, r is the round in which the block b became valid (i.e., the path b was included in tree).
Given a (record) chain C = (m0 , .
, m` ), we refer to the blocks in C as sub-paths m0 , .
, mk of C; we say that C is valid at a round r if all the blocks in C are valid at r.
We say that chain C was mined at round r if r was the first round in which C became valid.  Proof.
We first observe that the consistent length property holds, and then turn to lower-bounding the chain growth.
Consistent Length The following claim shows that if some honest player has a chain of length ` at round r, then all other honest players will have a chain of length at least ` at round r + ∆, which proves the desired consistent length property.
If in view, i is honest at r and j is honest at r + ∆, then |Cjr+∆ (view)| ≥ |Cir (view)| Proof.
Due to the fact that all messages are delivered within ∆ steps, we have that whenever some player either receives a chain of length ` all other honest players will receive the same chain within ∆ step; additionally, whenever an honest player mines a block, it broadcasts it to all other players and they will thus receive it within ∆ steps.
Chain Growth Towards proving the chain growth property, we first consider a hybrid experV iment.
Let HYBr (σ) denote the output of EXEC(Πtree ,Ctree ) (A0 , Z, κ) with the randomness of the experiment fixed to σ, where the experiment is modified as follows: after round r, a) fix all messages/actions by Z to be the ones in REAL(σ); b) remove all new messages sent by the adversary to honest players, and delay currently undelivered messages from corrupted parties to the maximum of ∆ round; c) delay all messages sent by honest players (that have not already been delivered by round r) to the maximum of ∆ rounds; and d) whenever some message is being delayed, all honest players “freeze” (i.e., stop “mining”) until the message is delivered.
Finally, let HYBr denote the output of HYBr (σ) for a randomly sampled σ.
The following lemma shows that the chain of every honest player cannot decrease in length if we maximally delay messages from honest parties, freeze all honest players during this delay, and drop all adversarial messages for every fixed randomness σ.
We emphasize that for this lemma to hold it is crucial that we consider the protocol in the Ftree model and not the random oracle model.
Otherwise, there exists randomness σ such that if we fixed the randomness of the experiment to σ, honest parties could end up on a “better path” once we, for example, remove adversarial message.
Additionally, to prove this lemma it is important that we fix the messages/actions of Z (which is enabled by us fixing σ), or else Z could “help” honest players if it notices that messages from A are delayed.
We prove the lemma by induction on t.
The base case (t = 0) is trivial.
Assume the lemma holds for all t0 < t.
We prove it for t.
Consider some σ and some player j that is honest at round s = r + t in REAL(σ) and assume for contradiction that |Cjs (REAL(σ))| < |Cjs (HYBr (σ))|.
We distinguish between two cases: j is corrupted at round s−1 in REAL(σ): Note that mining at round s is successful in HYBr (σ) only if it is successful in REAL(σ),12 so the only possibility of j’s chain to be longer in at round s in HYBr (σ) is if it started off with a longer chain in HYBr (σ), before it did its mining in this round.
We now argue that this is impossible.
Since j is honest at round s, j must have been “uncorrupted” in round s.
j will thus start with a “blank state” and receive incoming messages (sent by honest parties before round s − 1) and potentially also messages from the adversary.
By construction, the same players are honest in REAL(σ) and HYBr (σ).
In both experiments A needs to deliver all messages sent by these honest players in rounds on or before s − ∆; in HYBr (σ) these are the only messages being delivered, and in REAL(σ), A may deliver additional messages (from honest parties sent after s − ∆, or from adversarial players).
Let j 0 be the player that sends j its currently longest chain in HYBr (σ) and let r0 be the round when it “mined” this chain; since σ determines when players are successful in “mining” in both experiments, we have that j 0 also mines a chain in round r0 in REAL(σ) (and this chain will be delivered to j by round s).
By the induction hypothesis, the chain of j 0 at r0 is at least as long in REAL(σ) as in HYBr (σ), which contradicts that the chain of j (before mining) is longer in HYBr (σ).
j is honest at round s − 1 in REAL(σ): By the induction hypothesis we have that the chain of j is at least as long at round s − 1 in REAL(σ) as in HYBr (σ), thus the chain of j must have grown at round s in HYBr (σ) (or else it could not be longer at round s as we assumed for contradiction).
Also, note that mining at round s is successful in HYBr (σ) only if it is successful in REAL(σ),13 so the only possibility of j’s chain to be longer in HYBr (σ) is if it received a chain in round s that extended its chain.
This chain must have come from an honest player, since the exact same messages sent by corrupt parties and delivered in HYBr (σ) are also delivered in REAL(σ) at the same or earlier round.
Let j 0 be the honest player that sent the chain, and let r0 = s − ∆ be the round in which j 0 mined the chain; as before, we also have that j 0 mines a chain in round r0 in REAL(σ) and this chain must have been delivered to j by round s (and potentially earlier).
The chain delivered in REAL(σ) may not be the exact same chain delivered in HYBr (σ), but by the induction hypothesis the chain of j 0 at r0 is at least as long in REAL(σ) as in HYBr (σ), which contradicts that the chain of j is longer in HYBr (σ).
We turn to prove a lower bound on the chain growth of the longest chain known to the honest players.
Let `r (view) denote the length of the longest chain Cir (view) of any honest player i at round r in view.
Note that at every round s0 ≥ r in HYBr where the honest players are not frozen, they have all received all sent messages; they, thus, all have chains of the same length (but not necessarily the same chain).
In every such round, the probability that the longest chain (known to the honest parties) is successfully extended is thus exactly α, independent of the prefix of the experiment.
Towards proving the chain quality property, the following two simple lemmas will be useful.
Lemma 6.7 (Upperbound on Blocks).
Let Qt (view) be the maximum number of blocks mined in any windows of t rounds (i.e., between round r and r + t for any r) in view.
In t rounds, the adversary gets tρn chances to mine a block; each chance succeeds with probability p.
The desired bound follows directly from the Chernoff bound and a union bound over the rounds r.
Armed with these lemma, we are now ready to prove Theorem 4.2.
The following theorem (which proves the chain quality property for the protocol in the Ftree -hybrid model), combined with Lemma 5.1, yields Theorem 4.2.
Consider some view view in the support of REAL, some round r and player i that is honest at viewr .
Let C = Cir (view), let b0 , .
, b|C| be the blocks in C, let m0 , .
, m|C| be the records contained in them and let bj , .
, bj+T be T consecutive blocks in C for some j.
We say that a block bi is adversarial w.r.t.
view if bi was mined by the adversary in view; note that the record mi (s.t.
i ≥ j) contained in bi can only be adversarial w.r.t viewr and the prefix m0 , .
, mj−1 if bi is adversarial w.r.t view.
We show that except with probability neg(T ) over view ← REAL, the fraction of adversarial blocks in any such sequence bj , .
, bj+T is upper-bounded by (1 + δ) βγ .
Let us start by noting that it suffices to provide a bound assuming that bj−1 is not adversarial (i.e., it was either mined by an honest player, or it is the genesis block), and that bj+T +1 is not adversarial (i.e., it was either mined by an honest player or |C| = j + T ); otherwise, the fraction of adversarial blocks can only increase if we “enlarge” the segment (by considering a smaller j and/or a bigger T ).
Let r0 be the round when bj−1 was mined; since it was not adversarial it was the chain of some honest player at this point.
Let r0 +t be the round when bj+T first appeared as an honest players’ chain; by construction such a round exists (since bj+T +1 is not adversarial).
Note that by the definition of Ftree , all the adversarial blocks in bj , .
, bj+T must have been mined between round r0 and r0 + t.
We simplify the experiment by “ignoring” bad events that happen with negligible probability:  Towards proving consistency, we first show that if an adversary “withholds” a block for “too long”, it will never make it to the chain.
Let witholding-time(view) be the longest number of rounds t such that in view, 1) the adversary mines a block b at some round r, and 2) there exists some honest player i such that b appeared (for the first time) as i’s chain at round r + t.
Lemma 6.10 (“No long block witholding”).induction over r0 − r, it suffices to show the lemma for the special cases that a) r0 = r or b) r0 = r + 1; the base case of the induction is case a), and the inductive step follows directly from b) and the observation that if two chains do not diverge at r0 > r, then they clearly do not diverge at r either.
Whenever such a pattern occurs, unless the adversary mines a chain of length ` + 114 , where ` is the length of the longest chain known to the honest players when the pattern begins, there exists a unique block that can appear on position ` + 1 in any chain held by an honest player at round r (and thus by the definition of a block, the prefixes of all chains held by honest players are identical up until position ` + 1).
Intuitively this follows since, “after the first period of silence”, unless the adversary mines a chain of length ` + 1, the honest players all agree on the length of the chain (being exactly `), then agree on the newly mined block after the second silence; no honest player will therefore attempt to mine a chain that is shorter and thus will never mine a block for position `+1).
Furthermore, each new pattern gives rise to a new such “converge opportunity”.
Thus, unless between the rounds s and r0 ≤ s + (t + 1), the number of times the adversary succeeds in mining a chain of length ` + 1 (where as before ` is the length of the longest chain known to the honest players) is smaller than the number of such patterns, chains of honest players at rounds r, r0 cannot diverge at s.
The proof is concluded by showing that the number of such patterns increases at a faster rate than the number of blocks mined by the adversary; to do this, we rely on the block withholding lemma (Lemma 6.10) to argue that the adversary cannot make use of any blocks mined too long ago in order to create disagreement.
Now, consider some view view in the execution of REAL and consider some round r ≤ |view| and some t such that s = r − t ≥ 0.
We simplify the experiment by “ignoring” bad events that happen with negligible probability.
In the sequel we will define various random variables L(view), X(view), Ri (view); to simplify the notation, we omit view whenever it is clear from context.
• We say that a round r̃ in view is successful if there exists some honest player that mines a block at round r̃.
Note that (by definition), α is the probability that a round r̃ is successful.
Let L(view) be the number of successful rounds between s and r and let L = (1 − δ 0 ) αt for some constant 0 < δ 0 < 1.
Let bad1 be the event that L < L.
Formally, we consider an extended experiment where the honest players continue mining blocks forever (even after the environment Z stops sending them messages.
Additionally, by a union bound, the probability that either of these events occur is at most e−Ω(βt) .
Whenever such a convergence opportunity occurs, unless the adversary mines a chain of length ` + 1 before round r0 , where ` is the length of the longest chain known to the honest players when the convergence opportunity begins, there exists a unique block that can appear on position ` + 1 in any chain held by an honest player after the convergence opportunity and up until round r0 .
This follows because of three reasons: first, after the first ∆ period of silence, all honest parties have chains of the same length ` (the longest chain known to the honest players before the period of silence must have been delivered to all of them by this point, and the only way the adversary can disrupt this is if it mines a longer chain which is only possible if it first mines a chain of length ` + 1); secondly, there is a unique miner that succeeds in extending its chain, thus obtaining a chain of length ` + 1; and finally, by the end of the second period of silence, all players must have received this extension or potentially some other chain (by the adversary) which is at least as long, which means that no honest player will ever try to mine from a chain of length smaller than ` + 1 and thus no other block mined by an honest player can appear in position ` + 1 in any valid chain.
Additionally, note that at every such convergence opportunity, the length of the longest chain ` grows by at least 1.
Thus the only way for the chains of two honest player i, j at rounds r, r0 to diverge at s is if between the rounds s and r0 , the adversary mines a block of length ` + 1 for every such convergence opportunity (or else they will have a block in common after s, and thus in fact, all blocks in common up until this point).
Thus it needs to mine at least Tδ000 = (1 − δ 000 )(1 − 2α(∆ + 1))αt new blocks.
Furthermore, these blocks all need to be accepted by some honest player at round s (or later).
Since by Claim 6.12, there exists some constant 0 < δ̃ < 1 such that a) γ > (1 + δ̃)β, we can apply the block witholding lemma (Lemma 6.10), to conclude that for any constant ω, any such block must have been mined by round s − ωt except probability e−Ω(βt) .
By picking a sufficiently small δ 000 , ω, ω 0 , we have that Tδ000 is greater than this quantity, and it follows that the chains diverge at s only with probability e−Ω(βt) .
Armed with these lemmas, we now prove the following theorem (which proves consistency for the protocol in the Ftree -hybrid model), which combined with Lemma 5.1, yields Theorem 4.3.
For any λ > 1, any p(·), (Πptree , Ctree ) satisfies (errorless) consistency in Γpλ environments.
By Claim 6.12 and Lemma 6.10, for every constant 0 < ω < 1, except with probability neg(βt) = neg(ρnp) = neg(T ), at most ωt extra block may be accepted by some honest player in such a window.
Thus, except with probability neg(T ), the chain can grow by at most ((1 + δ 0 )np + ω) · t in any window; for every δ, by appropriately setting δ 0 , this quantity can be made smaller than (1+δ)np·t, which proves the theorem.
In this section, we demonstrate how to use any blockchain satisfying the growth, quality, and consistency properties defined in §3 to construct a secure public ledger system.
[GKL15] show a similar theorem, in the synchronous setting, for the specific blockchain of Nakamoto.
Informally, a public ledger serves as an immutable “bulletin board” to which anyone can post a message, and everyone can read all messages posted.
As descibed by Garay et al.
[GKL15], such a bulletin board ought to satisfy two properties, liveness and persistence:16 • Liveness: The liveness property stipulates that from any given round r, if a sufficiently long period of time t elapses—we refer to this time as the wait-time of the ledger—every honest player will output a message m as part of their (local) ledger, where m was provided as an input to some honest player between rounds r and r + t.
(In particular, this implies the liveness condition of [GKL15] which requires that if the same message was provided to all honest players between rounds r and r + t, this messages will be output in the ledger.) • Persistence: The persistence property stipulates that if some honest player i outputs a message m at position i in its local ledger, then 1) m is the only message that can ever be output at position i of any other honest player’s ledger and 2) every honest player will eventually output m at position i.
Just like the blockchain protocol, a public ledger is pair of algorithms (Π, L) where Π is a stateful algorithm that maintains a local state state.
The algorithm L(κ, state) outputs ordered se~ .
We call L(κ, state) the (local) ledger of a player with security parameter κ quence of messages m and local variable state.
The notion of Garay et al.
[GKL15] is actually somewhat different and weaker: for instance, 1) they only require these properties to hold for records that are sufficiently “deep” in the ledger (we feel it is more natural/simpler to require it for all records in the ledger), and 2) they only require the liveness property to hold if all players received the same message.
where the last inequality follows by picking sufficiently small δ 0 , δ 000 .
8  An Attack on Nakamoto with “Long” Delays  In this section, we formally demonstrate that Nakamoto’s protocol satisfies neither consistency nor positive chain quality, in a fully asynchronous network without an upperbound ∆ on the network delay, even if the adversary controls just a tiny fraction of computational power.
In particular, we present a “51%” attack a la Nakamoto—where the attacker at some point in the future replace the whole chain with a chain of its choice, even if it only controls a small fraction of the computational power.
Intuitively, in every segment of ∆ rounds, if we delay all messages between honest players until the end of the segment, honest players are effectively “mining on their own” and thus are unlikely to extend their chain by more than 1.
The adversary, on the other hand, may coordinate its mining and thus in expectation extends its chain by ∆ · ρnp; so if we set ∆ > ρnp the adversary can mine its own chain (without sending it to the honest player) and is likely to have a longer (private) chain.
Note that in any view view ∈ EXEC(Π ,C) (A, Z, κ) where 1) |Ĉ| > κ and 2) Ĉ is longer than the longest chain known to the honest players, we have that consistentκ (view) = 0 and qualityκ (view, 1) = 0.
We show that the probability that both events happen is constant, which proves the theorem.
The following two claims bound the probability that either event does not happen; by a union bound we can then conclude that the probability that both happen is constant.
Let Ĉ(view) denote the length of the adversary’s chain in the next to last round (i.e., round κ∆) of view.
Then, By a union bound over the number of players n and the number of segments κ, we have that except with probability 1+δ 2 ≤ 4 , no honest player mines more than one block in any segment, and whenever that happens, the length of the longest chain grows by at most 1 for each segement and thus becomes of length at most κ after κ segments.
We note that our proof applies even in the setting of static corruptions, and already to a weaker notion of consistency which ignores “future-self consistency”.
In addition, the attacker never looks at the messages sent by honest players.
We additionally point out that at the cost of complicating the proof (and increasing the number of players), we can obtain an even stronger attack—which works also when ∆ > c·np where 1c > ρ1 − 1−ρ (as opposed to just ρ1 as in our previous proof )—as follows: instead or partitioning the rounds into segments, simply always delay messages between honest players by ∆.
Intuitively (but significantly oversimlifying), when we delay the messages between honest parties by ∆, the expected time they need to wait until finding and propagating a block is roughly (1−ρ)np +∆, whereas the adversaries only needs to wait ρnp in expectation; thus, the attacker succeeds whenever it mines faster (i.e., when ρ1 < 1−ρ + ∆np), and since ∆np = 1c , the attack succeeds when 1c > ρ1 − 1−ρ .
We turn to describe how to formalize this attack (following the proof of 8.3).
We, in fact, show an attack that works as long as β > γ (i.e., the adversary mining rate is higher than the “discounted” honest player mining rate), and then use this to deduce that the attack applies when It follows using exactly the same proof as the lowerbound on chain growth in the “hybrid” model (see Claim 6.4) that we can get (1 + δ)γ as an upperbound on the chain growth of the honest players in a modified game where all honest players “freeze” for ∆ rounds whenever some honest player mines a block (just as in the “hybrid” model in Claim 6.4).
Since successes in each round are independent, it follows that conditioned on no single player ever mining two blocks within ∆ rounds, the chain growth of honest players is upperbounded by (1 + δ)γ, whereas the chain growth of the adversary is lowerbounded by (1 − δ)β.
Thus when β > (1 + δ 0 )γ, if we run the experiment for t steps (and condition on no single player ever mining two blocks within ∆ rounds), we get an attack except with probability e−Ω(γt) .
Since γ is monotonically increasing in α and α ≤ (1 − ρ)np, within ∆ rounds) when 1c > ρ1 − 1−ρ Finally, as in the proof of Claim 8.3 we have that at any given round r, for any fixed player j, the probability of j mining more that 1 block within the next ∆ rounds is upperbounded by (∆ − 1)2 p2 ≤ c21n2 .
Thus, if we set n > 2t, it follows that no player every mines more than 1 block within ∆ rounds, except with probability 1/2 (by the union bound)..