We present “Ouroboros,” the first blockchain protocol based on proof of stake with rigorous security guarantees. We establish security properties for the protocol comparable to
those achieved by the bitcoin blockchain protocol. As the protocol provides a “proof of stake”
blockchain discipline, it offers qualitative efficiency advantages over blockchains based on proof
of physical resources (e.g., proof of work). We also present a novel reward mechanism for incentivizing proof of stake protocols and we prove that, given this mechanism, honest behavior
is an approximate Nash equilibrium, thus neutralizing attacks such as selfish mining. We also
present initial evidence of the practicality of our protocol in real world settings by providing
experimental results on transaction confirmation and processing.

A primary consideration regarding the operation of blockchain protocols based on proof of work
(PoW)—such as bitcoin [34]—is the energy required for their execution. At the time of this writing, generating a single block on the bitcoin blockchain requires a number of hashing operations
exceeding 260 , which results in striking energy demands. Indeed, early calculations indicated that
the energy requirements of the protocol were comparable to that of a small country [36].
This state of affairs has motivated the investigation of alternative blockchain protocols that
would obviate the need for proof of work by substituting it with another, more energy efficient,
mechanism that can provide similar guarantees. Fundamentally, the proof of work mechanism of
bitcoin facilitates a type of robust randomized “leader election” process that elects one of the miners
to issue the next block. Furthermore—provided that all miners follow the protocol—this selection
is performed in a randomized fashion proportionally to the computational power of each miner.
(Deviations from the protocol may distort this proportionality as exemplified by “selfish mining”
strategies [25, 43].)
A natural alternative mechanism relies on the notion of “proof of stake” (PoS). Rather than
miners investing computational resources in order to participate in the leader election process, they
instead run a process that randomly selects one of them proportionally to the stake that each
possesses according to the current blockchain ledger.
In effect, this yields a self-referential blockchain discipline: maintaining the blockchain relies on
the stakeholders themselves and assigns work to them (as well as rewards) based on the amount
of stake that each possesses as reported in the ledger. Aside from this, the protocol should make
no further “artificial” computational demands on the stakeholders. In some sense, this sounds
ideal; however, realizing such a proof of stake protocol appears to involve a number of definitional,
technical, and analytic challenges.
Previous work. The concept of PoS has been discussed extensively in the bitcoin forum.1 Proof
of stake based blockchain design has been more formally studied by Bentov et al., both in conjunction with PoW [7] as well as the sole mechanism for a blockchain protocol [6]. Although Bentov
et al. showed that their protocols are secure against some classes of attacks, they do not provide
a formal model for analyzing PoS based protocols or security proofs relying on precise definitions.
Heuristic proof of stake based blockchain protocols have been proposed (and implemented) for a
number of cryptocurrencies.2 Being based on heuristic security arguments, these cryptocurrencies
have been frequently found to be deficient from the point of view of security. See [6] for a discussion
of various attacks.
It is also interesting to contrast a PoS-based blockchain protocol with a classical consensus
blockchain that relies on a fixed set of authorities (see, e.g., [21]). What distinguishes a PoS-based
blockchain from those which assume static authorities is that stake changes over time and hence
the trust assumption evolves with the system as well as the fact that the complexity of system
maintenance should be sublinear in the total number of users/stakeholders.
Another alternative to PoW is the concept of proof of space [2, 24], which has been specifically
investigated in the context of blockchain protocols [37]. In a proof of space setting, a “prover”
wishes to demonstrate the utilization of space (storage/memory); as in the case of a PoW, this
utilizes a physical resource but can demand less energy. A related concept is proof of space-time
(PoST) [32]. In all these cases, however, the protocol relies on an expensive physical resource (either
storage or computational power).
The PoS Design challenge. A fundamental problem for PoS-based blockchain protocols is to
simulate the leader election process. In order to achieve a fair randomized election among stakeholders, entropy must be introduced into the system, and mechanisms to introduce entropy may be
prone to manipulation by the adversary. For instance, an adversary controlling a set of stakeholders
may attempt to simulate the protocol execution trying different sequences of stakeholder participants so that it finds a protocol continuation that favors the adversarial stakeholders. This leads
to a so called “grinding” vulnerability, where adversarial parties may use computational resources
to bias the leader election.
Our Results. We present “Ouroboros,” a provably secure proof of stake system. To the best of
our knowledge this is the first blockchain protocol of its kind with a rigorous security analysis. In
more detail, our results are as follows.
First, we provide a model that formalizes the problem of realizing a PoS-based blockchain protocol. The model we introduce is in the spirit of [28], focusing on persistence and liveness, two formal
properties of a robust transaction ledger. Persistence states that once a node of the system proclaims a certain transaction as “stable,” the remaining nodes, if queried and responding honestly, will also report it as stable. Here, stability is to be understood as a predicate that will be parameterized by some security parameter k that will affect the certainty with which the property holds.
(E.g., “more than k blocks deep.”) Liveness ensures that once an honestly generated transaction
has been made available for a sufficient amount of time to the network nodes, say u time steps,
it will become stable. The conjunction of liveness and persistence provides a robust transaction
ledger in the sense that honestly generated transactions are adopted and become immutable. Our
model is suitably adapted to reflect PoS-based dynamics.
Second, we describe a novel blockchain protocol based on PoS. Our protocol assumes that
parties can freely create accounts and receive and make payments, and that stake shifts over time.
We utilize a (simple) secure multiparty implementation of a coin-flipping protocol to produce the
randomness for the leader election process. This distinguishes our approach (and prevents so called
“grinding attacks”) from other previous solutions that either defined such values deterministically
based on the current state of the blockchain or used collective coin flipping as a way to introduce
entropy [6]. Also, unique to our approach is the fact that the system ignores round-to-round
stake modifications. Instead, a snapshot of the current set of stakeholders is taken in regular
intervals called epochs; in each such interval a secure multiparty computation takes place utilizing
the blockchain itself as the broadcast channel. Specifically, in each epoch a set of randomly selected
stakeholders form a committee which is then responsible for executing the coin-flipping protocol.
The outcome of the protocol determines the set of elected stakeholders that will execute the protocol
in the subsequent epoch, as well as the outcomes of all leader elections for the epoch.
Third, we provide a set of formal arguments establishing that no adversary can break persistence
and liveness. Our protocol is secure under a number of plausible assumptions: (1) the network
is synchronous in the sense that an upper bound can be determined during which any honest
stakeholder is able to communicate with any other stakeholder, (2) a number of stakeholders drawn
from the honest majority is available as needed to participate in each epoch, (3) the stakeholders
do not remain offline for long periods of time, (4) the adaptivity of corruptions is subject to a small
delay that is measured in rounds linear in the security parameter (or alternatively, the players
have access to a sender-anonymous broadcast channel). At the core of our security arguments is a
probabilistic argument regarding a combinatorial notion of “forkable strings” which we formulate,
prove and also investigate experimentally. In our analysis we also distinguish covert attacks, a
special class of general forking attacks. “Covertness” here is interpreted in the spirit of covert
adversaries against secure multiparty computation protocols, cf. [3], where the adversary wishes to
break the protocol but prefers not to be caught doing so. We show that covertly forkable strings are
a subclass of the forkable strings with much smaller density; this permits us to provide two distinct
security arguments that achieve different trade-offs in terms of efficiency and security guarantees.
Our forkable string technique is a natural and general tool that may have applications beyond
analysis of our specific PoS protocol.
Fourth, we turn our attention to the incentive structure of the protocol. We present a novel
reward mechanism for incentivizing the participants to the system which we prove to be an (approximate) Nash equilibrium. In this way, attacks like block withholding and selfish-mining [25, 43]
are mitigated by our design. The core idea behind the reward mechanism is to provide positive
payoff for those protocol actions that cannot be stifled by a coalition of parties that diverges from
the protocol. In this way, it is possible to show that under plausible assumptions—namely that
certain protocol execution costs are small—following the protocol faithfully is an equilibrium when
all players are rational.
Fifth, we introduce a stake delegation mechanism that can be seamlessly added to our blockchain
protocol. Delegation is particularly useful in our context as we would like to allow our protocol
to scale even in a setting where the set of stakeholders is highly fragmented. In such cases, thedelegation mechanism can enable stakeholders to delegate their “voting rights,” i.e., the right of
participating in the committees running the leader selection protocol in each epoch. As in liquid
democracy (a.k.a. delegative democracy [27]), stakeholders have the ability to revoke their delegative
appointment when they wish, independently of each other.
Given our model and protocol description we also explore how various attacks considered in
practice can be addressed within our framework. Specifically, we discuss double spending attacks,
transaction denial attacks, 51% attacks, nothing-at-stake, desynchronization attacks and others.
Finally, we present evidence for the practical efficiency of our design. First we consider double
spending attacks. For illustrative purposes, we perform a comparison with Nakamoto’s analysis for
bitcoin regarding transaction confirmation time with assurance 99.9%. Against covert adversaries,
the transaction confirmation time is from 10 to 16 times faster than that of bitcoin, depending on
the adversarial hashing power; for general adversaries confirmation time is from 5 to 10 times faster.
Moreover, our concrete analysis of double-spending attacks relies on our combinatorial analysis of
forkable and covertly forkable strings and applies to a much broader class of adversarial behavior
than Nakamoto’s more simplified analysis.3 We then survey our prototype implementation and
report on benchmark experiments run in the Amazon cloud that showcase the power of our proof
of stake blockchain protocol in terms of performance.
Related and Follow-up Work. In parallel to the development of Ouroboros, a number of other
protocols were developed targeting various positions in the design space of distributed ledgers based
on PoS. Sleepy consensus [8] considers a fixed stakeholder distribution (i.e., stake does not evolve
over time) and targets a “mixed” corruption setting, where the adversary is allowed to be adaptive
as well as perform fail-stop and recover corruptions in addition to Byzantine faults. It is straightforward to extend our analysis in this mixed corruption setting, cf. Remark 2; nevertheless, the
resulting security can be argued only in the “corruptions with delay” setting, and thus is not fully
adaptive; in follow up work it is shown how our analysis can be extended to incorporate both
adaptive corruptions [22] as well as a more refined model of availability [4] that covers fail-stop and
recover/sleepy corruptions. Snow White [9] addresses an evolving stakeholder distribution and uses
a corruption delay mechanism similar to ours for arguing security. Contrary to our approach here
the leader election of [9] enables a degree of “grinding”, i.e., making it feasible to significantly bias
any adversarially chosen high probability event but affords a much more efficient randomness generation process. In follow-up work [22] it is shown how it is possible to obtain full adaptive security
and similarly efficient randomness generation extending the forkable strings analysis introduced in
the present paper. Algorand [31] provides a distributed ledger following a Byzantine agreement
per block approach that can withstand adaptive corruptions. Given that agreement needs to be
reached for each block, such protocols will produce blocks at a rate substantially slower than a PoS
blockchain (where the slow down matches the expected length of the execution of the Byzantine
agreement protocol); on the other hand, Algorand can be parameterised to be free of forks and
then blocks will “settle” immediately after the conclusion of each consensus sub-protocol. In particular full settlement will happen at expected constant number of rounds, which, asymptotically,
is superior to any blockchain protocol (it is worth noting that blockchain protocols somewhat mitigate this inherent slow-down by letting ledger users choose a different level of settlement security
depending on the value of transactions that are at risk or by using an overlay protocol such as
lightning [41]). This benefit comes at the expense of imposing specific participation bounds for
Nakamoto’s simplifications are pointed out in [28]: the analysis considers only the setting where a block withholding attacker acts without interaction as opposed to a more general attacker that, for instance, tries strategically
to split the honest parties in more than one chains during the course of the double spending attack.each sub-protocol instance which are unnecessary in the case of a blockchain protocol, see the follow up work on Ouroboros with dynamic availability [4] for further discussion on this topic. The
Algorand approach also does not require an agreed concept of time between the participants and
merely relies on the assumption that time passes with roughly the same speed. While the protocol
presented herein requires access to global time, in follow-up work, [5], it is shown how it is possible for the Ouroboros protocol to be enhanced with a time synchronization sub-protocol while
retaining the core security argument we present here. Fruitchain [40] provides a reward mechanism
and an approximate Nash equilibrium proof for a PoW-based blockchain. We use a similar reward
mechanism at the blockchain level, nevertheless our underlying mechanics are different since we
operate in a PoS setting. The core of the idea is to provide a PoS analogue of “endorsing” inputs in
a fair proportion using the same logic as the PoW-based byzantine agreement protocol for honest
majority from [28]. Finally, in the present paper we prove that the error bound for the commonprefix property (and thus persistence of transactions) has an error rate that drops sub-exponentially
with the security parameter, while experimentally we demonstrate an exponential drop. Follow up
work [42] shows how this gap can be closed by proving an exponentially decreasing error bound.
Paper overview. We lay out the basic model in Sec. 2. To simplify the analysis of our protocol,
we present it in four stages that are outlined in Sec. 3. In short, in Sec. 4 we describe and analyze
the protocol in the static setting; we then transition to the dynamic setting in Sec. 5. We then
present the protocol enhancement with anonymous channels in Sec. 7. Our incentive mechanism
and the equilibrium argument are presented in Sec. 8. Following this, we discuss delegation in
Sec. 9 and in Sec. 10, the resilience of the protocol under various particular attacks of interest.
Finally, in Sec. 11 we discuss transaction confirmation times as well as general performance results
obtained from a prototype implementation running in the Amazon cloud.
Time, slots, and synchrony. We consider a setting where time is divided into discrete units
called slots. A ledger, described in more detail below, associates with each time slot (at most) one
ledger block. Players are equipped with (roughly synchronized) clocks that indicate the current slot.
This will permit them to carry out a distributed protocol intending to collectively assign a block
to this current slot. In general, each slot is indexed by an integer r ∈ {1, 2, . . .}, and we assume
that the real time window that corresponds to each slot has the following properties.
The current slot is determined by a publicly-known and monotonically increasing function of
current time.
Each player has access to the current time. Any discrepancies between parties’ local time are
insignificant in comparison with the length of time represented by a slot.
The length of the time window that corresponds to a slot is sufficient to guarantee that
any message transmitted by an honest party at the beginning of the time window will be
received by any other honest party by the end of that time window (even accounting for
small inconsistencies in parties’ local clocks). In particular, while network delays may occur,
they never exceed the slot time window.
Transaction Ledger Properties. A protocol Π implements a robust transaction ledger provided
that the ledger that Π maintains is divided into “blocks” (assigned to time slots) that determine theorder with which transactions are incorporated in the ledger. It should also satisfy the following
two properties.
Once a node of the system proclaims a certain
transaction tx as stable, the remaining nodes, if queried, will report tx at the same position
of the ledger and agree on the entire prefix of the ledger (prior to tx). Stability is defined in
terms of the blockchain: a transaction is declared stable if and only if it is in a block that is
more than k blocks deep in the ledger.
If all honest nodes in the system attempt to include
a certain transaction, then after the passing of time corresponding to u slots (called the
transaction confirmation time), all nodes, if queried and responding honestly, will report the
transaction as stable.
Persistence and liveness can be derived from the following three elementary properties [28, 30, 39]
provided that protocol Π derives the ledger from a data structure in the form of a blockchain (or
simply chain) that each party maintains locally and updates at the onset of each slot. The properties
are as follows.
The chains C1 , C2 adopted by two honest
parties at the onset of the slots sl1 ≤ sl2 are such that C1  C2 , where C1 denotes the chain
obtained by removing the last k blocks from C1 , and  denotes the prefix relation.
Consider the
chain C adopted by an honest party. Let sl2 be the slot associated with the last block of C
and let sl1 be a prior slot in which C has an honestly-generated block.
Consider the chain C adopted
by an honest party at the onset of a slot and any portion of C spanning s prior slots; then at
least one honestly-generated block appears in this portion.
Some remarks are in place. This definition of common prefix reflects a strong variant of that
appearing in [30]. As for chain quality, we work with this simple “existential” formulation for
convenience. Previous work focused on a more general notion that bounds the density of honestlygenerated blocks in a sufficiently long portion of a chain. In fact, one can establish such a density
bound directly from existential chain quality along the lines of the proof of chain growth in Section 4.5.
As for chain growth, we focus on a version pertaining to the suffix of the chain following an
honest block. In fact, as we note in Section 4.5, combining ∃CQ and HCG one can directly infer the
following stronger version.
Chain Growth (CG); with parameters τ ∈ (0, 1] and s ∈ N. Consider the chain C
adopted by an honest party at the onset of a slot and any portion of C spanning s prior slots;
then the number of blocks appearing in this portion of the chain is at least τ s.
As in the case of bitcoin, the longest chain plays a preferred role in our protocol; this provides
a straightforward guarantee of honest chain growth.
We adopt the model introduced by [28] for analyzing security of blockchain
protocols enhanced with an ideal functionality F. 
We note that multiple different “functionalities” will be encompassed by F. Contrary to [28],
our analysis is in the “standard model,” and without a random oracle functionality. The first interfaces we incorporate in the ideal functionality used in the protocol are the “diffuse” and “key and
transaction” functionality, denoted FD+KT and described below. Note that the diffuse functionality
is also the mechanism via which we will obtain protocol synchronization.
Diffuse functionality. The diffuse functionality maintains an incoming string for each party Ui
that participates. A party, if activated, is allowed at any moment to fetch the contents of its
incoming string; one may think of this as a mailbox. Additionally, parties can instruct the
functionality to diffuse a message, in which case the message will be appended to each party’s
incoming string. The functionality maintains rounds (slots) and all parties activated in a
round are allowed to diffuse once. Rounds do not advance unless all activated parties have
diffused a message. The adversary, when activated, may also interact with the functionality;
it may read all inboxes and all diffuse requests and deliver messages to the inboxes in any
order it prefers. At the end of the round, the functionality will ensure that all inboxes contain
all messages that have been diffused (but not necessarily in the same order they have been
requested to be diffused). The current slot index may be requested at any time by any party.
If a party does not fetch in a certain slot the messages written to its incoming string, they
are flushed.
Key and Transaction functionality. The key registration functionality is initialized with n
users, U1 , . . . , Un , and their respective stakes, s1 , . . . , sn ; given such initialization, the functionality will consult with the adversary and will accept a (possibly empty) sequence of
(Corrupt, U ) messages and mark the corresponding users U as corrupt. For the corrupt users
without a registered public-key the functionality will allow the adversary to set their publickeys. For honest users the functionality will sample public/secret-key pairs and record them
based on a digital signature algorithm; we will consider two modes for key generation. In the
ideal mode, key generation will be outsourced to an instance of an ideal signature functionality; in the real mode, an actual digital signature algorithm will be utilized; (cf. Figure 1
where we make these two variants explicit). Public-keys of corrupt users will be marked as
such. Subsequently, any sequence of the following actions may take place: (i) A user may
request to sign or verify a message whereupon the functionality will respond accordingly, restricting signing requests to only the owners of the respective keys. (ii) The entire directory
of public-keys may be requested, whereupon the functionality will return it to the requesting
user. (iii) A new user may be requested to be created by a message (Create, U, C) from the
environment, in which case the functionality will follow the same procedure as above: it will
consult the adversary regarding the corruption status of U and will set its public and possibly
secret-key depending on the corruption status; additionally, it will store C as the suggested
initial state. The functionality will return the public-key to the environment upon successful
completion of this interaction. (iv) An existing user may be requested to be corrupted by the
adversary via a message (Corrupt, U ). A user can only be corrupted after a delay of D slots;
specifically, after a corruption request is registered, a timer is maintained and the corruption
will take place after D slots have passed according to the round counter maintained in the
Diffuse component of the functionality. Note that when running in real mode, a corruptionwill have the effect of revealing the secret-key to the adversary. In any case, the adversary
will be able to access the signing interface of any corrupted party.
We assume throughout that the execution of the protocol is with respect to a functionality
F that incorporates, at least, the above two functionalities. Further functionalities are explained
below. Note that a corrupted stakeholder U will relinquish its entire state to A; from this point on,
the adversary will be activated in place of the stakeholder U . Beyond any restrictions imposed by F,
the adversary can only corrupt a stakeholder if it is given permission by the environment Z running
the protocol execution. The permission is in the form of a message (Corrupt, U ) which is provided
to the adversary by the environment. The environment can give arbitrary permissions, however
with respect to an initial stakeholder set and respective stake, the adversary will be restricted to
controlling only a percentage of that stake, say a. In such case we refer to this adversary as an
a-initially-bounded adversary. In summary, regarding activations we have the following.
At each slot slj , the environment Z is allowed to activate any subset of stakeholders it
wishes. Each one of them will possibly produce messages that are to be transmitted to other
stakeholders.
The adversary is activated, at least, as the last entity in each slj (as well as during all
adversarial party activations).
It is easy to see that the model above confers such sweeping power on the adversary that one
cannot establish any significant guarantees on protocols of interest. It is thus important to restrict
the environment suitably (taking into account the details of the protocol) so that we may be able
to argue security. With foresight, the restrictions we will impose on the environment are as follows.
Restrictions imposed on the environment. The environment, which is responsible for activating the honest parties in each round, will be subject to the following constraints regarding the
activation of the honest parties running the protocol.
In each slot there will be at least one honest activated party.
There will be a parameter k ∈ Z that will signify the maximum number of slots that an honest
shareholder can be offline. In case an honest stakeholder is spawned after the beginning of
the protocol via (Create, U, C) its initialization chain C provided by the environment should
match an honest parties’ chain which was active in the previous slot.
The environment will distribute the transaction data d ∈ {0, 1}∗ to all parties, emulating the
effect of diffusing transactions in a peer-to-peer network. This transaction data, including
the required signatures by each stakeholder, is obtained by the environment as specified in
the protocol.
If the above
is violated, we say the event Bad /2−δ occurs for the given execution.
Stake shift is bounded over short periods. Specifically, for any chain adopted by an honest
party, the observed shift in stake distribution between “nearby” prefixes of the chain are
bounded from above. See Definition 5.2 for a precise definition.
We note that the availability assumption (restricting honest parties from long periods of disconnection) stated above is very conservative and our protocol can tolerate much longer offline
times depending on the course of the execution; nevertheless, for the sake of simplicity, we use
the above restriction. Finally, we note that in all of our proofs, whenever we say that a property
Q holds with high probability over all executions, we will in fact argue that Q ∨ Bad /2−δ holds
with high probability over all executions. This captures the fact that we exclude environments and
adversaries that trigger Bad /2−δ with non-negligible probability.
We first provide a general overview of the approach to design and analyze our protocol. The
protocol’s analysis will depend on a number of parameters: (i.) k is the number of blocks a certain
message should have “on top of it” in order to be treated as part of the immutable history of the
ledger, (ii.) , σ are parameters that bound adversarial stake and stake shift in the sense that the
adversary is (1/2 − )-initially bounded as well as (1/2 −  − σ)-bounded throughout the execution
and moreover stake shifts no more than σ occur over short enough time periods, (iii.) D is the
corruption delay that is imposed on the adversary, i.e., an honest stakeholder will be corrupted D
slots after the corresponding “corrupt” message is generated during an execution; (iv.) L is the
lifetime of the system, measured in slots; (v.) R is the length of an epoch, measured in slots (see
below for a discussion).
We present our protocol description in four stages, successively improving the adversarial model
it can withstand. In all stages an “ideal functionality” FLS is available to the participants. The
functionality captures the resources that are available to the parties as preconditions for the secure
operation of the protocol (e.g., the genesis block will be specified by FLS ).
Stage 1: Static stake; D = L = R. In the first stage, the trust assumption is static and remains
with the initial set of stakeholders; the execution is not further divided into epochs. There is an
initial stake distribution which is hardcoded into the genesis block that includes the public-keys of
the stakeholders. Based on our restrictions on the environment, adversarial stake of
no more than 1/2 is assumed among those initial stakeholders. Specifically, the environment initially will allow the corruption of a number of stakeholders whose relative stake represents 1/2.
The environment allows party corruption by providing tokens of the form (Corrupt, U ) to the adversary; note that due to the corruption delay imposed in this first stage any further corruptions will
be against parties that have no stake initially and hence the corruption model is effectively “static.”
FLS will subsequently sample ρ which will seed a “weighted by stake” stakeholder sampling and in
this way lead to the election of a subset of m keys to form the committee that will
possess honest majority with overwhelming probability in R, (this uses the fact that the relative
stake possessed by malicious parties is 1/2 − ; a linear dependency of R to −2 will be imposed at
this stage to guarantee applicability of strong concentration bounds). In more detail, the committee
will be selected implicitly by appointing a stakeholder with probability proportional to its stake to
each one of the L = R slots. Subsequently, stakeholders will issue blocks following the schedule thatis determined by the slot assignment. The longest chain rule will be applied and it will be possible
for the adversary to fork the blockchain views of the honest parties. Nevertheless, we will prove
with a novel combinatorial
argument that the probability of a k-common prefix violation drops
exponentially in k, cf. Theorem 4.24. Similar reasoning will yield favorable guarantees of chain
growth and chain quality. An even more favorable analysis can be made against covert adversaries,
i.e., adversaries that prefer to remain “under the radar” (cf. Section 6).
Stage 2: Dynamic stake with a beacon, adversarial look-ahead E, epoch period of
R slots, and delay D ≈ 2R  L. The central idea for the extension of the lifetime of the
above protocol is to consider the sequential composition of several invocations. We first describe a
protocol which relies on a trusted beacon that emits a uniformly random string at regular intervals.
Specifically, the beacon reveals the j-th random string that
seeds the leader election function for the following epoch. To simplify the relationship between
this stage and the next, which adopts a secure multiparty computation for randomness generation,
we expose the randomness beacon to the adversary E slots prior to exposure to honest parties;
this is the “adversarial look-ahead” parameter. The critical difference compared to the static stake
protocol is that the stake distribution is allowed to change and is drawn from the blockchain itself.
This means that the stake distribution adopted during the j-th epoch (with j ≥ 2) is determined
by the most recent block with time stamp less than (j − 1) · R − k 0 for an appropriate parameter. (The generic parameter k 0 appearing here is given a precise formula in the description of the
protocol.)
Regarding the evolving stake distribution, transactions will be continuously generated and transferred between stakeholders via the environment; players will incorporate posted transactions in the
blockchain-based ledgers that they maintain. In order to accommodate the new accounts that are
being created, the FLS functionality enables a new (vk, sk) to be created on demand and assigned to
a new party Ui . Specifically, the environment can create new parties who will interact with FLS for
their public/secret-key in this way treating it as a trusted component that maintains the secret of
their wallet. Note that the adversary can interfere with the creation of a new party, corrupt it, and
supply its own (adversarially created) public-key instead. As before, the environment may request
transactions between stakeholder accounts and can also generate transactions in collaboration with
the adversary on behalf of the corrupted accounts. Recall that our assumption is that at any slot,
in the view of any honest player, the stakeholder distribution places (1/2 +  + σ) stake majority
with the honest players (note that different honest players might perceive a different stakeholder
distribution in a certain slot). Furthermore, the stake distribution is guaranteed to shift by at most
σ statistical distance over a certain number of slots—this permits honest players to obtain reliable
estimates on past stake distributions by examining portions of their blockchains which may have
adversarial blocks. The security proof can be seen as an induction in the number of epochs L/R
with the base case supplied by the proof of the static stake protocol. In the end we will argue that
in this setting, a (1/2 −  − σ) bound in adversarial stake is sufficient for security of a single draw
(and observe that the size of committee, m, now should be selected to overcome also an additive
term of size ln(L/R) given that the lifetime of the system includes such a number of successive
epochs). The corruption delay is set to D ≈ 2R (in fact, it can be set more precisely as a function
of E and k 0 ), thus enabling the adversary to perform adaptive corruptions as long as these are not
instantaneous.
Stage 3: Dynamic stake without a beacon, epoch period of R slots, and delay D ≈ 2R 
L. In the third stage, we remove dependence on the beacon by introducing a secure multipartyprotocol with “guaranteed output delivery” that effectively simulates it. In this way, we can obtain
the long-livedness of the protocol as described in the stage 2 design but under the weaker assumptions of the stage 1 design, i.e., the mere availability of an initial random string and stakeholder
distributions with honest majority. The core idea is the following: given that we guarantee that an
honest majority among elected stakeholders will hold with very high probability, we can further use
this elected set as participants in an instance of a (simple) secure multiparty computation (MPC)
protocol. Naturally, this will require the choice of the length of the epoch to be sufficient so that
it can accommodate a run of the MPC protocol. From a security point of view, the main challenge
is to demonstrate that the MPC suitably simulates a beacon with the relaxation that the output
may become known to the adversary before it is known to the honest parties. A feature of this
stage—from a cryptographic design perspective—is the use of the ledger itself for the simulation of
a reliable broadcast that supports the MPC protocol.
Stage 4: Input endorsers, stakeholder delegates, anonymous communication. In the
final stage of our design, we augment the protocol with two new roles for the entities that are
maintaining the ledger and consider the benefits of anonymous communication. Input-endorsers
create a second layer of transaction endorsing prior to block inclusion. This mechanism enables
the protocol to withstand deviations such as selfish mining and enables us to show that honest
behaviour is an approximate Nash equilibrium under reasonable assumptions regarding the costs
of running the protocol. Note that input-endorsers are assigned to slots in the same way that
slot leaders are, and inputs included in blocks are only acceptable if they are endorsed by an
eligible input-endorser. Second, the delegation feature allows stakeholders to transfer committee
participation to selected delegates that assume the responsibility of the stakeholders in running
the protocol (including participation to the MPC and issuance of blocks). Delegation naturally
gives rise to “stake pools” that can act in the same way as mining pools in bitcoin. Finally, we
observe that by including an anonymous communication layer we can remove the corruption delay
requirement that is imposed in our analysis. This is done at the expense of increasing the online
time requirements for the honest parties.

We begin by describing the blockchain protocol πSPoS in the “static stake” setting, where leaders
are assigned to blockchain slots with probability proportional to their (fixed) initial stake which
will be the effective stake distribution throughout the execution. To simplify our presentation, we
abstract this leader selection process, treating it simply as an “ideal functionality” that faithfully
carries out the process of randomly assigning stakeholders to slots. In the following section, we
explain how to instantiate this functionality with a specific secure computation.
We remark that—even with an ideal leader assignment process—analyzing the standard “longest
chain” preference rule in our PoS setting appears to require significant new ideas. The challenge
arises because large collections of slots (epochs, as described above) are assigned to stakeholders at
once; while this has favorable properties from an efficiency (and incentive) perspective, it furnishes
the adversary a novel means of attack. Specifically, an adversary in control of a certain population
of stakeholders can, at the beginning of an epoch, choose when standard “chain update” broadcast
messages are delivered to honest parties with full knowledge of future assignments of slots tostakeholders. Additionally, an adversary in control of a particular slot may freely generate multiple
blocks associated with the slot, perhaps committing to distinct prior blockchains, and strategically
advertise them to honest players. In contrast, adversaries in typical PoW settings are constrained
to make decisions in an online fashion and cannot freely generate multiple blocks. We remark that
this can have a dramatic effect on the ability of an adversary to produce alternate chains; see the
discussion on “forkable strings” below for detailed discussion.
In the static stake case, we assume that a fixed collection of n stakeholders U1 , . . . , Un interact
throughout the protocol. Stakeholder Ui possesses si stake before the protocol starts. For each
stakeholder Ui a verification and signing key pair (vki , ski ) for a prescribed signature scheme is
generated; we assume without loss of generality that the verification keys vk1 , . . . are known by all
stakeholders. Before describing the protocol, we establish basic definitions following the notation
of [28].
The genesis block B0 contains the list of stakeholders identified
by their public-keys, their respective stakes (vk1 , s1 ), . . . , (vkn , sn ) and auxiliary information ρ.
With foresight we note that the auxiliary information ρ will be used to seed the slot leader
election process.
 A block B generated at a slot sl ∈ {1, . . . , R} contains the current state
st ∈ {0, 1}λ , data d ∈ {0, 1}∗ , the slot number sl and a signature σ = Signsk (st, d, sl) computed
under sk corresponding to the stakeholder U generating the block at that slot.
A blockchain (or simply chain) relative to the genesis block B0 is a
sequence of blocks B1 , . . . , Bn associated with a strictly increasing sequence of slots for which the
state sti of Bi is equal to H(Bi−1 ), where H is a prescribed collision-resistant hash function. The
length of a chain len(C) = n is its number of blocks. The block Bn is the head of the chain, denoted
head(C). We treat the empty string ε as a legal chain and by convention set head(ε) = ε.
Let C be a chain of length n and k be any non-negative integer. We denote by C dk the chain
resulting from removal of the k rightmost blocks of C. If k ≥ len(C) we define C dk = ε. We let
C1  C2 indicate that the chain C1 is a prefix of the chain C2 . We let C[k] = Bk and adopt interval
notation to reflect contiguous portions of a chain: specifically, C[k : `] = Bk , . . . , B` and parentheses
are used to indicate removal of endpoint so that, for example, C[k : `) = Bk , . . . , B`−1 .
 An epoch is a set of R adjacent slots S = {1, . . . , R}.
(The relevant value R is a parameter of the protocol we analyze in this section.)
Let UA be the set of stakeholders controlled by an
adversary A. Then the adversarial stake ratio is defined
where n is the total number of stakeholders and si is stakeholder Ui ’s stake.
Reflecting corruption delay. In general, we consider adversaries subject to a corruption delay,
which imparts a delay between the time when the adversary selects a party for corruption and the
time when the party actually passes into adversarial control. With such an adversary, parties whichhave been identified for corruption but are not yet under adversarial control are counted in the
adversarial stake ratio.
Unambiguous stake distributions. In principle, it is possible for various honest parties to disagree
on the current (or a previous) stake distribution. We avoid these ambiguities by explicitly identifying
a stake distribution when considering adversarial stake ratio.
Slot Leader Selection. In the protocol described in this section, for each 0 < j ≤ R, a slot
leader Ej is determined who has the (sole) right to generate a block at slj . Specifically, for each
slot a stakeholder Ui is selected as the slot leader with probability pi proportional to its stake
registered in the genesis block B0 ; these assignments are independent between slots. In this static
stake case, the genesis block as well as the procedure for selecting slot leaders are determined by an
ideal functionality FLS , defined in Figure 1. This functionality is parameterized by the set of initial
stakeholders {(U1 , s1 ), . . . , (Un , sn )} assigning to each stakeholder its respective stake, a distribution
D that provides auxiliary information ρ and a leader selection function F defined below.
 A leader selection process with respect to stakeholder
distribution S = {(vk1 , s1 ), . . . , (vkn , sn )}, (D, F) is a pair consisting of a distribution and a deterministic function such that, when ρ ← D it holds that for all slj ∈ {sl1 , . . . , slR }, F(S, ρ, slj ) outputs
where si is the stake held by stakeholder Ui (we call this “weighting by stake”); furthermore the
family of random variables {F(S, ρ, slj )}R
j=1 are independent.
We note that sampling proportional to stake can be implemented in a straightforward manner.
For instance, a simple process operates as follows. Let p̃i = si / nj=i sj . For each i = 1, . . . , n − 1,
provided that no stakeholder has yet been selected, the process flips a p̃i -biased coin; if the result
of the coin is 1, the party Ui is selected for the slot and the process is complete. (Note that p̃n = 1,
so the process is certain to complete with a unique leader.) When we implement this process as
a function F (·), sufficient randomness must be allocated to simulate the biased coin flips. If we
implement the above with λ precision for each individual coin flip, then selecting a stakeholder will
require ndlog λe random bits in total. Note that using a pseudorandom number generator (PRG)
one may use a shorter “seed” string and then stretch it using the PRG to the appropriate length.
A Protocol in the FLS [mode]-hybrid model. We start by describing a simple PoS based
blockchain protocol considering static stake in the FLS [SIG]-hybrid model, i.e., where the genesis
block B0 (and consequently the slot leaders) are determined by the ideal functionality FLS [SIG].
FLS [SIG] provides the stakeholders with a genesis block containing a stake distribution indexed by
signature verification keys generated by a EUF-CMA signature scheme, while FLS [FDSIG ] obtains
such keys from a signature ideal functionality FDSIG . This subtle difference comes into play when
describing an ideal version of πSPoS used in an intermediate hybrid argument of the security proof,
which will be discussed in Section 4.2. The stakeholders U1 , . . . , Un interact among themselves and
with FLS through Protocol πSPoS described in Figure 2.
We are interested in applications where transactions are inserted in the ledger. In our analysis,
we will consider simple coin transfer transactions of the format “stakeholder vk1 transfers to stakeholders vk2 an amount of x coins.” A transaction will consist of a transaction template tx of this
format accompanied by a signature of tx under the signing key corresponding to vk1 . We define a
valid transaction as follows.
FLS [mode] incorporates the diffuse and key/transaction functionality FD+KT from Section 2 and is parameterized by the respective stakes of the initial stakeholders S0 = {(U1 , s1 ), . . . , (Un , sn )}, a distribution D
and a function F so that (D, F) is a leader selection process. In addition, FLS [mode] is parameterized by
mode, which determines how signature verification keys are generated. When FLS [mode] is instantiated
with mode = SIG (resp. mode = FDSIG ) it is denoted FLS [SIG] (resp. FLS [FDSIG ]). FLS interacts with
stakeholders as follows:
Signature Key Pair Generation: FLS [SIG] generates signing and verification keys ski , vki for
stakeholder Ui by executing KG(1κ ) for i = 1, . . . , n. FLS [FDSIG ] generates (ski , vki ) by querying
FDSIG (Figure 3) with (KeyGen, sidi ) on behalf of Ui (with a unique session identifier sidi related
to Ui ) and setting (ski = sidi , vki = vi ) (received from FDSIG as response) for i = 1, . . . , n. In
either case, FLS [mode] sets S00 = {(vk1 , s1 ), . . . , (vkn , sn )}.
Genesis Block Generation Upon receiving (genblock req, Ui ) from stakeholder Ui , FLS proceeds
as follows. If ρ has not been set, FLS samples ρ ← D. In any case, FLS sends (genblock, S00 , ρ, F)
to Ui .
Signatures and Verification. For signing and verification requests on behalf of user Ui ,
FLS [FDSIG ] provides access to the corresponding FDSIG interface, while FLS [SIG] utilizes (ski , vki )
to respond restricting access of signing to the respective secret-key owners.

A pair (tx, σ) is considered a valid transaction by a verifier
V if the following holds:
The transaction template tx is of the format “stakeholder vk1 transfers to stakeholder vk2 an
amount of x coins with transaction serial number sn” where vk1 is a verification key contained
in the current stake distribution S and x ∈ Z.
The ledger cannot contain two transactions issued from the same stakeholder with the same
serial number sn; thus a transaction is only valid with respect to a blockchain if no previous
transaction (from the same stakeholder) has the same serial number.
For simplicity we assume that all properly signed transactions are valid and are included in
the ledger; in particular this means that there is a way to parse the ledger and disambiguate any
recorded double/overspents (e.g., following the order that is imposed by the ledger).
Given Definitions 4.4 and 4.8, we define a valid chain as a blockchain (according to Definition 4.4) where all transactions contained in every block are valid (according to Definition 4.8).
The protocol relies on a maxvalidS (C, C) function that chooses a chain given the current chain C
and a set of valid chains C that are available in the network. In the static case we analyze the
simple “longest chain” rule. (In the dynamic case the rule is parameterized by a common chain
length; see Section 5.)
Function maxvalid(C, C): Returns the longest chain from C ∪ {C}. Ties are broken in
favor of C, if it has maximum length, or arbitrarily otherwise.
πSPoS is a protocol run by stakeholders U1 , . . . , Un interacting with FLS [SIG] over a sequence of slots
S = {1, . . . , R}. πSPoS proceeds as follows:
Initialization Stakeholder Ui ∈ {U1 , . . . , Un }, receives from the key registration interface its
public and secret key. Then it receives the current slot from the diffuse interface and in case it
is sl1 it sends (genblock req, Ui ) to FLS [SIG], receiving (genblock, S0 , ρ, F) as answer. Ui sets the
local blockchain C = B0 = (S0 , ρ) and the initial internal state st = H(B0 ). Otherwise, it receives
from the key registration interface the initial chain C, sets the local blockchain to C and the initial
internal state st = H(head(C)).
Chain Extension For every slot slj ∈ S, every stakeholder Ui performs the following steps.
Ui receives from the environment the transaction data d ∈ {0, 1}∗ to be inserted into the
blockchain.
Collect all valid chains received via broadcast into a set C, verifying that for every chain C 0 ∈
C and every block B 0 = (st0 , d0 , sl0 , σ 0 ) ∈ C 0 it holds that Vrf vk0 (σ 0 , (st0 , d0 , sl0 )) = 1, where vk0
is the verification key of the stakeholder U 0 = F(S0 , ρ, sl0 ). Ui computes C 0 = maxvalid(C, C),
sets C 0 as the new local chain and sets state st = H(head(C 0 )).
If Ui is the slot leader determined by F(S0 , ρ, slj ), it generates a new block B = (st, d, slj , σ)
where st is its current state, d ∈ {0, 1}∗ is the transaction data and σ = Signski (st, d, slj ) is a
signature on (st, d, slj ). Ui computes C 0 = C|B, broadcasts C 0 , sets C 0 as the new local chain
and sets state st = H(head(C 0 )).
Transaction generation Upon receiving a transaction template tx from the environment, Ui
computes σ = Signski (tx) provided that tx is consistent with the state of the ledger in the view of
Ui ) and sends (tx, σ) to the environment.
As a first step of the security analysis of πSPoS , we will introduce an idealized protocol πiSPoS and
present an intermediate hybrid argument that shows that it is computationally indistinguishable
from πSPoS . Instead of relying on FLS [SIG] and an EUF-CMA signature scheme, πiSPoS operates
with an ideal signature scheme. To that end, πiSPoS interacts with FLS [FDSIG ] for obtaining signing
and verification keys for the ideal signature scheme employed in the protocol. In the next sections, we will prove that πiSPoS is secure through a series of combinatorial arguments. This hybrid
approach insulates these combinatorial arguments from the specific details of the underlying signature schemes used to instantiate πSPoS and the biases that these schemes might introduce in the
distributions of πSPoS.
First, in Figure 3, we present Functionality FDSIG as defined in [16], where it is also shown that
EUF-CMA signature schemes realize FDSIG . Notice that this fact will be used to show that our
idealized protocol can actually be realized based on practical digital signature schemes (such as
DSA and ECDSA) and ultimately that πiSPoS is indistinguishable from πSPoS .
The idealized protocol πiSPoS is run by the stakeholders interacting with FLS [FDSIG ] and FDSIG .
Basically, πiSPoS behaves exactly as πSPoS except for calls to Vrf vk (σ) and Signsk (m). Namely, instead
of locally computing Signski (m), Ui sends (Sign, sid, m) to FDSIG , receiving (Signature, sid, m, σ)
and outputting σ as the signature. Moreover, instead of locally computing Vrf vk0 (σ, m), Ui sends
(Verify, sidi , m, σ, v 0 ) to FDSIG (where v 0 corresponds to verification key vk0 ), outputting the value
f received in message (Verified, sidi , m, f ). Protocol πiSPoS is described in Figure 4. This idealized
description will be further developed when arguing about the dynamic stake case, where additional 
building blocks must be considered in the idealized protocol.
Key Generation Upon receiving a message (KeyGen, sid) from a stakeholder Ui , verify that sid =
(Ui , sid0 ) for some sid0 . If not, then ignore the request. Else, hand (KeyGen, sid) to the adversary.
Upon receiving (VerificationKey, sid, v) from the adversary, output (VerificationKey, sid, v) to Ui ,
and record the pair (Ui , v).
Signature Generation Upon receiving a message (Sign, sid, m) from Ui , verify that sid =
(Ui , sid0 ) for some sid0 . If not, then ignore the request. Else, send (Sign, sid, m) to the adversary. Upon receiving (Signature, sid, m, σ) from the adversary, verify that no entry (m, σ, v, 0)
is recorded. If it is, then output an error message to Ui and halt. Else, output (Signature, sid, m, σ)
to Ui , and record the entry (m, σ, v, 1).
Signature Verification Upon receiving a message (Verify, sid, m, σ, v 0 ) from some stakeholder
Ui0 , hand (Verify, sid, m, σ, v 0 ) to the adversary. Upon receiving (Verified, sid, m, φ) from the adversary do:
If v 0 = v and the entry (m, σ, v, 1) is recorded, then set f = 1. (This condition guarantees
completeness: If the verification key v 0 is the registered one and σ is a legitimately generated
signature for m, then the verification succeeds.)
Else, if v 0 = v, the signer is not corrupted, and no entry (m, σ 0 , v, 1) for any σ 0 is recorded,
then set f = 0 and record the entry (m, σ, v, 0). (This condition guarantees unforgeability: If
v 0 is the registered one, the signer is not corrupted, and never signed m, then the verification
fails.)
Else, if there is an entry (m, σ, v 0 , f 0 ) recorded, then let f = f 0 . (This condition guarantees consistency: All verification requests with identical parameters will result in the same
answer.)
Else, let f = φ and record the entry (m, σ, v 0 , φ).
Output (Verified, sid, m, f ) to Ui0 .
The following proposition is an immediate corollary of the results in [16] showing that EUF-CMA
signature schemes realize FDSIG.
In light of the above proposition in the remaining of the analysis we will focus on the properties
of the protocol πiSPoS (note that this implication does not apply to any5 possible property one
might consider in an execution for πiSPoS ; nevertheless the properties we will prove for πiSPoS
are all verifiable by the environment Z and as a result they can be inherited by πSPoS due to
proposition 4.9).
πiSPoS is a protocol run by stakeholders U1 , . . . , Un interacting with FLS [FDSIG ] over a sequence of slots
S = {1, . . . , R}. πiSPoS proceeds as follows:
Initialization Stakeholder Ui ∈ {U1 , . . . , Un }, receives from the key registration interface its
public and secret key. Then it receives the current slot from the diffuse interface and in case it
is sl1 it sends (genblock req, Ui ) to FLS [FDSIG ], receiving (genblock, S0 , ρ, F) as answer. Ui sets the
local blockchain C = B0 = (S0 , ρ) and the initial internal state st = H(B0 ). Otherwise, it receives
from the key registration interface the initial chain C, sets the local blockchain to C and the initial
internal state st = H(head(C)).
Chain Extension For every slot slj ∈ S, every stakeholder Ui performs the following steps:
Collect all valid chains received via broadcast into a set C, verifying that for every
chain C 0 ∈ C and every block B 0 = (st0 , d0 , sl0 , σ 0 ) ∈ C 0 it holds that FDSIG answers
with (Verified, sid, (st0 , d0 , sl0 ), 1) upon being queried with (Verify, sid, (st0 , d0 , sl0 ), σ 0 , vk0 ),
where vk0 is the verification key of the stakeholder U 0 = F(S0 , ρ, sl0 ). Ui computes
C 0 = maxvalid(C, C), sets C 0 as the new local chain and sets state st = H(head(C 0 )).
If Ui is the slot leader determined by F(S0 , ρ, slj ), it generates a new block B = (st, d, slj , σ)
where st is its current state, d ∈ {0, 1}∗ is the transaction data and σ is obtained from
FDSIG ’s answer (Signature, sid, (st, d, slj ), σ) upon being queried with (Sign, sidi , (st, d, slj )).
Ui computes C 0 = C|B, broadcasts C 0 , sets C 0 as the new local chain and sets state st =
H(head(C 0 )).
Transaction generation Given a transaction template tx, Ui returns σ obtained from FDSIG ’s
answer (Signature, sidi , tx, σ) upon being queried with (Sign, sidi , tx), provided that tx is consistent
with the state of the ledger in the view of Ui.
Fix an execution E with genesis block B0 , adversary A,
and environment Z. Let S = {i + 1, . . . , i + n} denote a sequence of slots of length |S| = n. The
characteristic string w ∈ {0, 1}n of S is defined so that wk = 1 if and only if the adversary controls
the slot leader of slot i + k. For such a characteristic string w ∈ {0, 1}∗ we say that the index i is
adversarial if wi = 1 and honest otherwise.
We start with some intuition for our approach to analyze the protocol. Let w ∈ {0, 1}n be
a characteristic string for a sequence of slots S. Among the fundamental properties we wish to
ensure of our protocol (CP, ∃CQ, and HCG), common prefix (CP) will require the most technical
effort. In this section, we develop a graph-theoretic abstraction to facilitate reasoning about these
properties, principally motivated by the task of establishing CP.
To motivate this, consider two observers that (i.) go offline immediately prior to the commencement of a sequence of slots S, (ii.) have adopted the same current chain C0 prior to the
commencement of S, and (iii.) come back online at the last slot of S and request an update of their
chain. A fundamental concern in our analysis is the possibility that such observers can be presented
with a “diverging” view over the sequence S: specifically, the possibility that the adversary can
force the two observers to adopt two different chains C1 , C2 whose common prefix is exactly C0 . We
observe that not all characteristic strings permit this. For instance the (entirely honest) string 0n
ensures that the two observers will adopt the same chain C which will consist of n new blocks on top
of the common prefix C0 . On the other hand, other strings do not guarantee such common extension
of C0 ; in the case of 1n , it is possible for the adversary to produce two completely different historiesduring the sequence of slots S and thus furnish to the two observers two distinct chains C1 , C2 that
only share the common prefix C0 . The bulk of the proof that the Ouroboros protocol achieves CP
relies on the fact that characteristic
√ strings permitting such “forkings” are quite rare—indeed, we
show that they have density 2−Ω( n) so long as the fraction of adversarial slots is 1/2 − .
To reason about the protocol at a more abstract level, we define below a formal notion of
“fork” that captures the relationship between the chains adopted by honest slot leaders during an
execution of the protocol πiSPoS . In preparation for the definition, we recall that honest players
always choose to extend a maximum length chain among those available to the player on the
network. Furthermore, if such a maximal chain C includes a block B previously broadcast by an
honest player, the prefix of C prior to B must entirely agree with the chain (terminating at B)
broadcast by this previous honest player. This “confluence” property follows immediately from the
fact that the state of any honest block effectively commits to a unique chain beginning at the genesis
block. To conclude, any chain C diffused by an honest player must begin with a chain produced
by a previously honest player (or, alternatively, the genesis block), continue with a possibly empty
sequence of adversarial blocks and, finally, terminate with an honest block. It follows that the
chains broadcast by honest players form a natural directed tree. The fact that honest players
reliably broadcast their chains and always build on the longest available chain introduces a second
important property of this tree: the “depths” of the various honest blocks added by honest players
during the protocol must all be distinct.
Of course, the actual chains induced by an execution of πiSPoS are comprised of blocks containing
a variety of data that are immaterial for reasoning about forking or the other elementary chain
properties. For this reason the formal notion of fork below merely reflects the directed tree formed
by the relevant chains and the identities of the players—expressed as indices in the string w—
responsible for generating the blocks in these chains.
Forks and forkable strings. We define, below, the basic combinatorial structures we use to
reason about the possible views observed by honest players during a protocol execution with this
characteristic string.
A fork F for the string w = 010100110; vertices appear with their labels and honest
vertices are highlighted with double borders. Note that the depths of the (honest) vertices associated
with the honest indices of w are strictly increasing. Two tines are distinguished in the figure: one,
labeled t̂, terminates at the vertex labeled 9 and is the longest tine in the fork; a second tine t
terminates at the vertex labeled 3. The quantity gap(t) indicates the difference in length between t
and t̂; in this case gap(t) = 4. The quantity reserve(t) = |{i | `(v) < i ≤ |w| and wi = 1}| indicates
the number of adversarial indices appearing after the label of the last honest vertex v of the tine;
in this case reserve(t) = 3. As each leaf of F is honest, F is closed.Definition 4.11 (Fork). Let w ∈ {0, 1}n and let H = {i | wi = 0} denote the set of honest indices.
A fork for the string w is a directed, rooted tree F = (V, E) with a labeling ` : V → {0, 1, . . . , n} so
that each edge of F is directed away from the root, the root r ∈ V is given the label `(r) = 0, the labels along any directed path in the tree are strictly increasing, each honest index i ∈ H is the label of exactly one vertex of F, the function d : H → {1, . . . , n}, defined so that d(i) is the depth in F of the unique vertex v for which `(v) = i, is strictly increasing. (Specifically, if i, j ∈ H and i < j, then d(i) < d(j).)
As a matter of notation, we write F ` w to indicate that F is a fork for the string w. We say that
a fork is trivial if it contains a single vertex, the root.
 A path in a fork F originating at the root is called a
tine. For a tine t we let length(t) denote its length, equal to the number of edges on the path. For
a vertex v, we let depth(v) denote the length of the (unique) tine terminating at v. The height of
a fork (as usual for a tree) is defined to be the length of the longest tine.
We overload the notation `() so that it applies to tines, by defining `(t) , `(v), where v is
the terminal vertex on the tine t. We borrow the “truncation operator,” described earlier in the
paper for chains: for a tine t we let tdk denote the tine obtained by removing the last k edges; if
length(t) ≤ k, we define tdk to consist solely of the root.
If a vertex v of a fork is labeled with an adversarial index (i.e., w`(v) = 1) we say that the vertex
is adversarial; otherwise, we say that the vertex is honest. For convenience, we declare the root
vertex to be honest. We extend this terminology to tines: a tine is honest if it terminates with an
honest vertex and adversarial otherwise. By this convention the empty tine t is honest.
The fork of honestly constructed chains. As discussed above, with an execution E of πiSPoS
one can naturally associate a characteristic string w and a fork FD ` w corresponding to the chains
constructed and diffused by honest participants during the protocol. See Figure 5 for an example,
which also demonstrates some of the quantities defined above and in the remainder of this section.
The fork shown in the figure reflects an execution in which (i.) the honest player associated with
the first slot builds directly on the genesis block (as it must), (ii.) the honest player associated with
the third slot is shown a chain of length 1 produced by the adversarial player of slot 2 (in addition
to the honestly generated chain of step (i.)), which it elects to extend, (iii.) the honest player
associated with slot 5 is shown a chain of length 2 building on the chain of step (i.) augmented
with a further adversarial block produced by the player of slot 4, etc.
We remark that the tight correspondence described above between forks and executions requires
that a slot is marked as adversarial if the owner of that slot ever fell under adversarial control
during the protocol; this is one direct indication of the challenge of “long-range attacks” which
involve corruption of slot leaders long after they have been awarded leadership. In our long-lived
protocols, such attacks are mitigated by a bounded-depth longest-chain rule which permits analysis
of forks whose characteristic strings are determined by the corruption schedule of an adversary over
a bounded period of time.
We begin by defining a natural notion of inclusion for two forks. If w is a prefix of the string w0 ∈ {0, 1}∗ , F ` w, and F 0 ` w0 ,
we say that F is a prefix of F 0 , written F v F 0 , if F is a consistently-labeled subgraph of F 0 .
Specifically, every vertex and edge of F appears in F 0 and, furthermore, the labels given to any
vertex appearing in both F and F 0 are identical.
If F v F 0 , each tine of F appears as the prefix of a tine in F 0 . In particular, the labels appearing
on any tine terminating at a common vertex are identical and, moreover, the depth of any honest
vertex appearing in both F and F 0 is identical.
In many cases, it is convenient to work with forks that do not “commit” anything beyond final
honest indices.
A fork is closed if each leaf is honest. By convention the trivial
fork, consisting solely of a root vertex, is closed.
Note that the fork FD discussed above of corresponding to honestly created chains is closed:
Every chain constructed by an honest player naturally terminates with block broadcast in an honest
slot. We remark that a closed fork has a unique longest tine (as all maximal tines terminate with
an honest vertex, and these must have distinct depths). Note, additionally, that if w̌ is a prefix of
w and F ` w, then there is a unique closed fork F̌ ` w̌ for which F̌ v F . In particular, taking
w̌ = w, we note that for any fork F ` w, there is a unique closed fork F ` w for which F v F ; in
this case we say that F is the closure of F .
The fork of adopted chains. Consider now the valid chains adopted by the honest participants
of the protocol. This set clearly includes all chains constructed (and diffused) by honest participants;
on the other hand, it may contain additional valid chains delivered by the adversary to honest
participants. In particular, we may associate a fork FA ` w with these adopted chains and note
that FD v FA . The fork FA is not, in general, closed. Note, however, that maximal tines in this
fork—as they have been adopted by an honest player according to the longest chain rule—must
have length no less than any chain previously diffused by an honest player. We begin by precisely
defining this notion.
Definition 4.15 (Viability). Let F ` w be a fork for a string w ∈ {0, 1}n and let t be a tine of F .
We say that t is viable if, for all honest indices h ≤ `(t), we have
d(h) ≤ length(t) .
(Recall that `(t) is the label of the terminal vertex of t.)
If t is viable, an honest participant (or observer) witnessing the execution at time `(t)—if
provided the tine t along with all honest tines generated up to time `(t)—could conceivably select
t via the maxvalid() rule. Observe that any honest tine is viable: by definition, the depth of the
terminal vertex of an honest tine exceeds that of all prior honest vertices. As remarked above, all
maximal tines appearing in FA are viable.
Let w ∈ {0, 1}n be a characteristic string. We define the following properties of w which are direct
analogues of the general protocol properties defined above. Given a tine t and a sequence of slots S
such that `(t) ≥ max S, we refer to a “portion of t spanning S” as the maximum subgraph t0 of t such
that `(v) ∈ S ∧ v ∈ t =⇒ v ∈ t0 . We use the notation t(S) to denote this subgraph. We continueto use interval notation for sequences of slots: that is, [sl1 : sl2 ] = {sl1 , . . . , sl2 } and parentheses in
place of brackets indicate that the endpoint is left out. Thus [sl1 : sl2 ) = {sl1 , . . . , sl2 − 1}. As a
final matter of notation, we often elide the parentheses in expressions such as t([sl1 , sl2 ]), simply
writing t[sl1 , sl2 ]. We will refer to a “portion of t spanning s slots” when the particular sequence of
slots is not specified.
Common Prefix (cp); with parameter k ∈ N. A characteristic string w possesses k-cp if,
for every fork F ` w and every pair of viable tines t1 and t2 of F for which `(t1 ) ≤ `(t2 ), the
time t1 is a prefix of t2 . (Equivalently, length(t1 ) − length(t1 ∩ t2 ) ≤ k, where t1 ∩ t2 denotes
the common prefix of the two tines.)
Honest-Bounded Chain Growth (hcg); with parameters τ ∈ (0, 1] and s ∈ N. A
characteristic string w possesses hcg with parameters τ and s if, for every fork F ` w, every
viable tine t of F , and every honest vertex v on t for which `(v)+s ≤ `(t), the path t(`(v), `(t)]
contains at least τ s vertices.
Chain Growth (cg); with parameters τ ∈ (0, 1] and s ∈ N. A characteristic string
w possesses (τ, s)-cg if, for every fork F ` w and every viable tine t of F , any portion of t
spanning s slots contains at least τ s vertices.
Existential Chain Quality (∃cq); with parameter s ∈ N. A characteristic string w
possesses s-∃cq if, for every fork F ` w and every viable tine t of F , any portion of t spanning
s slots contains at least one honest vertex.
Anticipating the proofs in the next few sections, we record a Chernoff–Hoeffding bound and an
elementary stochastic dominance argument.
Theorem 4.16 (Chernoff–Hoeffding bound; see, e.g., [33]). Let X1 , . . . , XT be independent random
variables with Xi ∈ [0, 1]. 
For two elements x, y ∈ {0, 1}n , we write x ≤ y if, for each i, xi ≤ yi . With this
partial order, we define a notion of monotone subsets of {0, 1}n : A subset E ⊆ {0, 1}n is monotone
if, for each pair x, y ∈ {0, 1}n , x ∈ E and x ≤ y implies that y ∈ E. Let X and Y be two random
variables taking values in {0, 1}n . We write X ≺ Y if Pr[X ∈ E] ≤ Pr[Y ∈ E] for any monotone
set E. In this case, we say that Y stochastically dominates X.
Lemma 4.18. Let X = (X1 , . . . , Xn ) be a family of random variables taking values in {0, 1} with
the property that, for each i > 0, E[Xi | X1 , . . . , Xi−1 ] ≤ p. Let B = (B1 , . . . , Bn ) be a family of
independent random variables, taking values in {0, 1}, for which E[Bi = 1] = p. Then X ≺ B.
Proof. We proceed by induction. The statement is clear for n = 1. In general, consider a random
variable X satisfying the conditions of the theorem and taking values in {0, 1}n+1 ; let E ⊂ {0, 1}n+1
be a monotone event. We wish to prove that Pr[X ∈ E] ≤ Pr[B ∈ E].
Consider a characteristic string w = w1 . . . wL
drawn in {0, 1}L so that each wi is independently assigned the value 1 with probability 1/2 −  for
some  ∈ (0, 1/2). Then, for s > 0,
Pr[w does not satisfy s-∃cq] ≤ ∃cq (s; L, ) , (−2 + 3)/2 L exp(−22 s) .
Proof. An s-∃cq violation for w consists of a fork F ` w and a viable tine t for which there is a
pair of indices sl1 and sl2 so that sl1 + s ≤ sl2 ≤ `(t) and t(sl1 : sl2 ] contains no honest vertices.
For such a violation, let sl∗1 denote the largest index of an honest vertex in t[0 : sl1 ]—note that the
root of F is honest by fiat so that sl∗1 is well-defined. Similarly, let sl∗2 denote the smallest index
for which sl2 ≤ sl∗2 ≤ `(t) and t[0 : sl∗2 ] is viable. This is also well defined since t is viable. Observe
that no sl2 ≤ sl∗ ≤ sl∗2 can index an honest vertex of t; otherwise, sl∗ > sl2 (by assumption) but the
tine t[0 : sl∗ − 1] would be viable—as it supports extension by an honest vertex—which contradicts
minimality of sl∗2 . As we assume that s > 0,
sl∗1 ≤ sl1 < sl1 + s ≤ sl2 ≤ sl∗2
and observe that t(sl∗1 , sl∗2 ] contains no honest vertices. We define the rank of this violation to be
the quantity ` = sl∗2 − sl∗1 and refer to sl∗2 as the target of the violation; we say that the pair (sl∗2 ; `)
is the signature of such a violation. Note that the rank ` of a s-∃cq violation is always at least s.
 Note that t[0 : sl∗1 ] = t0 and that length(ti−1 ) < length(ti ) for each
0 < i ≤ g. As t[0 : sl∗2 ] is viable and hslg is honest, we note that length(tg ) ≤ length(t[0 : sl∗2 ]). To
conclude,
length(t[0 : sl∗2 ]) ≥ length(t[0 : sl∗1 ]) + g .
We remark that g = #0 (ŵ), where ŵ = wsl∗1 +1 , . . . , wsl∗2 , and note that ` = |ŵ|. On the other hand,
as t(sl∗1 , sl∗2 ] contains no honest vertex we have the immediate upper bound
length(t[0 : sl∗2 ]) ≤ length(t[0 : sl∗1 ]) + #1 (ŵ) ,
where #1 (ŵ) denotes the number of adversarial indices in ŵ. Thus #1 (ŵ) ≥ #0 (ŵ).
Fixing a particular signature (sl, `) it follows that
Pr[w admits an s-∃CQ violation with signature (sl; `)]

We begin with the lemma below demonstrating that chain growth (cg) follows from existential
chain quality (∃cq) and honest-bounded chain growth (hcg).
In particular, assuming shcg ≥ 2s∃cq , the execution satisfies cg with parameter τ ≥ τhcg /2.
(The last inequality follows because the function fλ (x) = (x − λ)/x,
for any λ > 0, is strictly increasing for x > 0—thus (†) is minimized when ŝ = sHCG + 2s∃CQ .) The
statement of the lemma follows.
We now establish concrete bounds on hcg; coupled with the conclusions about ∃cq from Section 4.4, this will yield our desired bounds on cg.
Lemma 4.22 (Abstract Chain Growth). Consider w = w1 , . . . , wL drawn in {0, 1}L so that each
wi independently takes the value 1 with probability 1/2 − . Then for s > 0, we have
Pr[w does not satisfy (1/4, s)-cg] ≤ cg (1/4, s; L, ) , (−2 + 4)L exp(−2 s/2) .
Structural features of forks: Reach, gap, reserve, and margin.

Likewise, we define the margin of F , denoted µ(F ), to be the “penultimate” reach taken over edge disjoint tines of F : specifically,

We remark that the maxima above can always be obtained by honest tines. Specifically, if t is
an adversarial tine of a fork F ` w, reach(t) ≤ reach(t), where t is the longest honest prefix of t.
As ∼ is an equivalence relation on the nonempty tines, it follows that there is always a pair of
(edge-disjoint) tines t1 and t2 achieving the maximum in the defining equation (2) which satisfy
reach(t1 ) = ρ(F ) ≥ reach(t2 ) = µ(F ).
The relevance of margin to the notion of forkability is reflected in the following proposition.
Proposition 4.27. A string w is forkable if and only if there is a closed fork F ` w for which
margin(F ) ≥ 0.
If w has no honest indices, then the trivial fork consisting of a single root node is flat, closed,
and has non-negative margin; thus the two conditions are equivalent. Consider a forkable string w
with at least one honest index and let î denote the largest honest index of w. Let F be a flat fork
for w and let F ` w be the closure of F (obtained from F by removing any adversarial vertices from
the ends of the tines of F ). Note that the tine t̂ containing î is the longest tine in F , as this is the
largest honest index of w. On the other hand, F is flat, in which case there are two edge-disjoint
tines t1 and t2 with length at least that of t̂. The prefixes of these two tines in F must clearly have
reserve no less than gap (and hence non-negative reach); thus margin(F ) ≥ 0 as desired.
On the other hand, suppose w has a closed fork with margin(F ) ≥ 0, in which case there are
two edge-disjoint tines of F , t1 and t2 , for which reach(ti ) ≥ 0. Then we can produce a flat fork by
simply adding to each ti a path of gap(ti ) vertices labeled with the subsequent adversarial indices
promised by the definition of reserve().
We remark that the definitions do not guarantee a priori
that ρ(w) and µ(w) can be achieved by the same fork, though this will be established in the lemma
below. In any case, it is clear that ρ(w) ≥ 0 and ρ(w) ≥ µ(w) for all strings w; furthermore, by
Proposition 4.27 a string w is forkable if and only if µ(w) ≥ 0. We refer to µ(w) as the margin of
the string w.
In preparation for the proof of Theorem 4.24, we establish a recursive description for these
quantities.
Furthermore, for every string w, there is a closed fork Fw ` w for which m(w) = (ρ(Fw ), µ(Fw )).
The proof proceeds by induction. If w = , define F to be the trivial fork; F ` w is the
unique closed fork for this string and m() = (0, 0) = (ρ(F ), µ(F )), as desired.
In general, we consider m(w0 ) for a string w0 = wx—where w ∈ {0, 1}∗ and x ∈ {0, 1}; the
argument recursively expands m(w0 ) in terms of m(w) and the value of the last symbol x. In each
case, we consider the relationship between two closed forks F v F 0 where F ` w and F 0 ` w0 = wx.
In the case where x = 1, we must have F = F 0 as graphs, because the forks are assumed to
be closed; it is easy to see that the reach of any tine t of F ` w has increased by exactly one
when viewed as a tine of F 0 ` w0 . We write reachF 0 (t) = reachF (t) + 1, where we introduce the
notation reach () to denote the reach in a particular fork. It follows that ρ(F 0 ) = ρ(F ) + 1 and
µ(F 0 ) = µ(F ) + 1. If F ∗ ` w0 is a closed fork for which ρ(F ∗ ) = ρ(w0 ), note that F ∗ may be
treated as a fork for w and, applying the argument above, we find that ρ(w0 ) ≤ ρ(w) + 1. A similar
argument implies that µ(w0 ) ≤ µ(w) + 1. On the other hand, by induction there is a fork Fw for
which m(w) = (ρ(Fw ), µ(Fw )) and hence m(w0 ) ≥ (ρ(w) + 1, µ(w) + 1). We conclude that
m(w0 ) = (ρ(w) + 1, µ(w) + 1) .
Moreover, m(w0 ) = (ρ(Fw ), µ(Fw )), where Fw is treated as a fork for w0 = w1.
The case when x = 0 is more delicate. As above, we consider the relationship between two
closed forks F ` w and F 0 ` w0 = w0 for which F v F 0 . Here F 0 is necessarily obtained from F
by appending a path labeled with a string of the form 1a 0 to the end of a tine t of F . (In fact,
it is easy to see that we may always assume that this is appended to an honest tine.) In order
for this to be possible, gap(t) ≤ reserve(t) (which is to say that reach(t) ≥ 0) and, in particular,
gap(t) ≤ a ≤ reserve(t): for the first inequality, note that the depth of the new honest vertex
must exceed that of the deepest (honest) vertex in F and hence a ≥ gap(t); as for the second
inequality, there are only reserve(t) possible adversarial indices that may be added to t and hence
a ≤ reserve(t). We define the quantity ã ≥ 0 by the equation a = gap(t) + ã and let t0 denote the
tine (of F 0 ) resulting by extending t in this way. We say that ã is the parameter for this pair of
forks F v F 0.Of course, every honest tine t of F is an honest tine of F 0 and it is clear that reachF 0 (t) =
reachF (t) − (ã + 1), as the length of the longest tine t0 in F 0 exceeds the length of the longest tine
of F by exactly ã + 1. Note that the reach of the new honest tine t0 (in F 0 ) is always 0, as both
gap(t0 ) and reserve(t0 ) are zero. It remains to describe how µ(w) and ρ(w) are determined by this
process.
The case ρ(w) > µ(w) = 0. By induction, there is a fork Fw for which m(w) = (ρ(Fw ), µ(Fw )).
Let t1 and t2 be edge-disjoint tines of Fw for which ρ(Fw ) = reach(t1 ) and µ(Fw ) = reach(t2 ).
Define F 0 ` w0 to be the fork obtained by extending the tine t2 of Fw with parameter ã = 0
to yield a new tine t02 in F 0 . Then reachF 0 (t1 ) = ρ(w) − 1 and reachF 0 (t02 ) = 0. It follows that
ρ(w0) ≥ ρ(w) − 1 and µ(w0) ≥ 0. We will show that ρ(w0) ≤ ρ(w) − 1 and that µ(w0) ≤ 0,
in which case we can conclude that
Moreover, the fork Fw0 = F 0 achieves these statistics, as desired.
We return to establish that ρ(w0) ≤ ρ(w) − 1 and that µ(w0) ≤ 0. Let F ∗ ` w0 be a closed
fork for which ρ(w0) = ρ(F ∗ ) and let F ` w be the unique closed fork for which F v F ∗ ;
as above, let ã denote the parameter for this extension. Let t∗ be an honest tine of F ∗ so
that reachF ∗ (t∗ ) = ρ(w0). If t∗ is a tine of F , reachF ∗ (t∗ ) = reachF (t∗ ) − (ã + 1) ≤ ρ(w) − 1.
Otherwise t∗ was obtained by extension and reachF ∗ (t∗ ) = 0 ≤ ρ(w) − 1 by assumption. In
either case ρ(w0) ≤ ρ(w) − 1, as desired. It remains to show that µ(w0) ≤ 0. Now consider
F ∗ ` w0 to be a closed fork for which µ(F ∗ ) = µ(w0). Let t∗1 and t∗2 be two edge-disjoint
honest tines of F ∗ so that reachF ∗ (t∗1 ) = ρ(F ∗ ) and reachF ∗ (t∗2 ) = µ(F ∗ ) = µ(w0). Let F ` w
be the unique closed fork for which F v F ∗ and let ã be the parameter for this extension.
If both t∗1 and t∗2 are tines of F , reachF ∗ (t∗i ) = reachF (t∗i ) − (ã + 1) and, in particular,
reachF (t∗1 ) ≥ reachF (t∗2 ). It follows that reachF (t∗2 ) ≤ µ(F ) ≤ µ(w) = 0 and hence that
µ(w0) < 0. Otherwise, one of the two tines was the result of extension and has zero reach()
in F ∗ . As reachF ∗ (t∗1 ) ≥ reachF ∗ (t∗2 ), in either case it follows that µ(F ∗ ) = reachF ∗ (t∗2 ) ≤ 0,
as desired.
The case ρ(w) = 0. By induction, there is a fork Fw for which m(w) = (ρ(Fw ), µ(Fw )). Let t1
and t2 be edge-disjoint tines of Fw for which ρ(Fw ) = reach(t1 ) and µ(Fw ) = reach(t2 ). Define
F 0 ` w0 to be the fork obtained by extending the tine t1 of Fw with parameter ã = 0 to yield
a new tine t01 in F 0 . Then reachF 0 (t01 ) = 0 and reachF 0 (t2 ) = reachF (t2 ) − 1. It follows that
ρ(w0) ≥ 0 and µ(w0) ≥ µ(w) − 1. We will show that ρ(w0) ≤ 0 and that µ(w0) ≤ µ(w) − 1,
in which case we can conclude that
Moreover, the fork Fw0 = F 0 achieves these statistics, as desired.
We return to establish that ρ(w0) ≤ 0 and that µ(w0) ≤ µ(w) − 1. Let F ∗ ` w0 be a
closed fork for which ρ(w0) = ρ(F ∗ ) and let F ` w be the unique closed fork for which
F v F ∗ ; as above, let ã denote the parameter for this extension. Let t∗ be an honest tine
of F ∗ so that reachF ∗ (t∗ ) = ρ(w0). Note that t∗ cannot be a tine of F ; if it were then
reachF ∗ (t∗ ) = reachF (t∗ ) − (ã + 1) ≤ ρ(w) − 1 < 0 which contradicts ρ(w0) ≥ 0. Thus t∗
was obtained by extension and reachF ∗ (t∗ ) = 0. It remains to show that µ(w0) ≤ 0. Now let
F ∗ ` w0 be a closed fork for which µ(F ∗ ) = µ(w0). Let t∗1 and t∗2 be two edge-disjoint honest
tines of F ∗ so that reachF ∗ (t∗1 ) = ρ(F ∗ ) and reachF ∗ (t∗2 ) = µ(F ∗ ) = µ(w0). Let F ` w be theunique closed fork for which F v F ∗ and let ã be the parameter for this extension. Similarly,
t∗1 cannot be a tine of F ; if it were, ρ(F ∗ ) = reachF ∗ (t∗1 ) = reachF (t∗1 ) − (ã + 1) ≤ ρ(F ) − 1 ≤
ρ(w) − 1 < 0 which contradicts ρ(F ) ≥ 0. It follows that t∗1 must extend a tine t1 of F for
which reachF (t1 ) = 0, because extension can only occur for tines of non-negative reach and
ρ(F ) = 0 = ρ(w). Thus t∗2 is a tine of F and t1 6∼ t∗2 so that reachF (t∗2 ) ≤ µ(F ) ≤ µ(w) and
we conclude that µ(w0) = reachF ∗ (t∗2 ) ≤ reachF (t∗2 ) − 1 ≤ µ(w) − 1, as desired.
The case ρ(w) > 0, µ(w) 6= 0. By induction, there is a fork Fw for which m(w) = (ρ(Fw ), µ(Fw )).
Let t1 and t2 be edge-disjoint tines of Fw for which ρ(Fw ) = reach(t1 ) and µ(Fw ) = reach(t2 ).
In fact, any extension of Fw will suffice for the construction; for concreteness, define F 0 `
w0 to be the fork obtained by extending the tine t1 of Fw with parameter ã = 0. Then
reachF 0 (ti ) = reachFw (ti ) − 1. It follows that ρ(w0) ≥ ρ(w) − 1 and µ(w0) ≥ µ(w) − 1. 
Moreover, the fork Fw0 = F 0 achieves these statistics, as desired.
We return to establish that ρ(w0) ≤ ρ(w) − 1 and that µ(w0) ≤ µ(w) − 1. Let F ∗ ` w0 be a
closed fork for which ρ(w0) = ρ(F ∗ ) and let F ` w be the unique closed fork for which F v F ∗ ;
as above, let ã denote the parameter for this extension. Let t∗ be an honest tine of F ∗ so that
reachF ∗ (t∗ ) = ρ(w0). Note that if t∗ is a tine of F then reachF ∗ (t∗ ) = reachF (t∗ ) − (ã + 1) ≤
ρ(w) − 1; otherwise t∗ is obtained by extension and reachF ∗ (t∗ ) = 0 ≤ ρ(w) − 1, as desired.
(Recall that ρ(w) > 0.) It remains to show that µ(w0) ≤ µ(w) − 1. Now let F ∗ ` w0 be a
closed fork for which µ(F ∗ ) = µ(w0). Let t∗1 and t∗2 be two edge-disjoint honest tines of F ∗ so
that reachF ∗ (t∗1 ) = ρ(F ∗ ) and reachF ∗ (t∗2 ) = µ(F ∗ ) = µ(w0). Let F ` w be the unique closed
fork for which F v F ∗ and let ã be the parameter for this extension. If both t∗1 and t∗2 are
tines of F then reachF ∗ (t∗i ) = reachF (t∗i ) − (ã + 1) and, in particular, reachF (t∗1 ) ≥ reachF (t∗2 )
so that reachF (t∗2 ) ≤ µ(w) and reachF ∗ (t∗2 ) ≤ µ(w) − 1, as desired.
To complete the argument, we consider the case that one of the tines t∗i arises by extension.
Note that in this case reachF ∗ (t∗2 ) ≤ 0, as either t∗2 is obtained by extension so that it has zero
reach, or t∗1 is obtained by extension so that reachF ∗ (t∗2 ) ≤ reachF ∗ (t∗1 ) = 0. Here we further
separate the analysis into two cases depending on the sign of µ(w):
• If µ(w) > 0, then reachF ∗ (t∗2 ) ≤ 0 ≤ µ(w) − 1, as desired.
• If µ(w) < 0 then t∗2 cannot be the extension of a tine in F . To see this, suppose to the
contrary that t∗2 extends a tine t2 of F ; then reachF (t2 ) ≥ 0. Additionally, t∗1 must be a
tine of F , edge-disjoint from t2 , and reachF (t∗1 ) = reachF ∗ (t∗1 ) + (ã + 1) > 0. It follows
that µ(w) ≥ µ(F ) ≥ 0, a contradiction.
The other possibility is that t∗1 is an extension of a tine t1 of F in which case reachF (t1 ) ≥
0. Note that t∗2 is a tine of F and edge-disjoint from t1 ; thus min(reachF (t∗2 ), reachF (t1 )) ≤
µ(F ) < 0 and reachF (t∗2 ) ≤ µ(F ). We conclude that reachF ∗ (t∗2 ) = reachF (t∗2 )−(ã+1) ≤
µ(w) − 1, as desired.
With this recursive description in place, we return to the proof of Theorem 4.24, which we
restate below for convenience.
Let  ∈ (0, 1) and let w be a string drawn from {0, 1}n by independently
assigning each wi = 1 with probability (1 − )/2.In light of the properties (4) above, the random variables Rt are quite well-behaved when
positive—in particular, considering the distribution placed on each wi , they simply follow the
familiar biased random walk of Figure 6. Likewise, considering the properties (5), the random
variables Mt follow a biased random walk when negative. The remainder of the proof combines
these probability laws with (6) and the fact that Mt () ≤ Rt () to establish that Mn < 0 with high
probability.

Partitioning the string w, we write w = w(1) · · · w( n) where w(t) = w1+at−1 . . . wat and at = dt ne,
for t = 0, 1, . . .. Let R(0) = 0 and R(t) = Rat ; similarly define M(0) = 0 and M(t) = Mat . Fix δ  
to be a small constant.
We define three events based on the random variables R(t) and M(t) :
Note that the event Vol0 occurs by definition. Assuming these inequalities, we observe that the
system is very likely to eventually become cold, and stay that way. In this case, Cold√n occurs,
Mn◦ < δ n < 0, and w is not forkable. Specifically, note √that the probability that the system
ever transitions from volatile to hot is no more than 2−Ω( n) (as transition from Vol to Hot is
bounded above by 2−Ω( n) , and there are no more than n possible transition opportunities).
Note, also, that while the system is volatile, it transitions to cold with constant probability during
each period. In particular, the probability that the system is volatile for the entire process is no
more that 2−Ω( n) . Finally, note√ that the probability that the system ever transitions out of the
cold state is no more than 2−Ω( n) (again, there are at most n √possible times when this could
happen, and any individual transition occurs with probability
2−Ω( n) ). It follows that the system
is cold at the end of the process with probability 1 − 2.
It remains to establish the three inequalities (9), (10), and (11).
Inequality (9): This follows directly from (4) and (7). Specifically, in light of (5) the random
variables Mi follow the probability law of the simple biased walk when they are negative.
Conditioned on M(t) = Mat < −δ n, the probability that any future Ms ever climbs to the
value −1 is no more than α−δ n = 2−Ω(n) , as desired. (Here α < 1 is a fixed constant that
depends only on .)
According to (8), then, where we take T = 2δ n, Pr[D] ≤ 2−Ω( n) . With near certainty, then,
the random variables Ri visit the value 0 during this period. Observe that if Ri = 0 then,
by (6), Mi+1 ≤ −1 with constant probability and (conditioned on this), by (7), with constant
probability the subsequent random variables Mj do not return to the value 0. 
is no more than ( n)2 2−Ω( n) . It follows that with constant probability, the walk (of Ri )
hits 0, as described above, and then Mi terminates at a value less than −δ n.
Inequality (11): This follows from (4), (6), (7), and (8). Specifically, conditioned on Volt , R(t) ≤
δ n. Recall from (4) that the random variables Ri follow the probability law of the simple
biased walk when they are positive. Let D be the event that Ri > 0√for all at ≤ i < at +2δ n.
According to (8), then, where we take T = 2δ n, Pr[D] ≤ 2−Ω( n) . With near certainty,
then, the random variables Ri visit the value 0 during this period. Conditioned on D, in order
for Rat+1 ≥ δ n there must be a sequence of these random variables 0 = Ri , Ri+1 , . . . , Rj =
bδ nc so that none of these take the value 0 except the first. (Such a sequence arises by
taking i to be the last time the variables Rat , . . . visit 0 and j the first subsequent time
that the sequence is larger than δ n.) In light of (7), the√probability of such a subsequence
appearing at a particular value for i is
no more√than α−δ n . It follows that the probability
that Rat+1 ≥ δ n is less than nα
= 2−Ω( n) , as desired.
Exact probabilities of forkability for explicit values of n. In order to gain further insight
regarding the density of forkable strings, we exactly computed the probability that a string w—
drawn so that each wi is independently assigned the value 1 with probability p ∈ {.40, .41, . . . , .50}—
is forkable for several different lengths. These results are presented in Figure 8.
Reducing common prefix to forkability. Returning now to the challenge of common prefix,
we note that the random assignment of slots to stakeholders given by FLS guarantees that the
coordinates of the associated characteristic string w are independent Bernoulli random variables
taking the value 1 with probability equal to the adversarial stake. Thus Theorem 4.24 establishes
In the context of πiSPoS , however, we wish to establish a much stronger common prefix property:
any pair of chains which could, in principle, be presented by the adversary to an honest party must
have a “recent” common prefix, in the sense that removing a small number of blocks from the
shorter chain results in a prefix of the longer chain.
To formally articulate and prove this property, we introduce a further definition regarding tines
and forks.
Let F be a fork for a string w ∈ {0, 1}∗ . For two viable tines t and
t0 of F we define the notation t/t0 by the rule
t/t0 = length(t) − length(t ∩ t0 ) ,
where t ∩ t0 denotes the common prefix of t and t0 . Then define the divergence of two viable tines
t1 and t2 to be the quantity. We overload this notation by defining divergence for F as the maximum over all pairs of viable
tines.
Finally, define the divergence of w to be the maximum such divergence over all possible forks for w:
div(w) = max div(F ) .
Observe that if div(t1 , t2 ) ≤ k and, say, `(t1 ) ≤ `(t2 ), the tine t1 is a prefix of t2 .
Divergence and common prefix violations. Divergence directly reflects the possibility of a
common prefix violation. In particular, the characteristic string w satisfies k-cp if and only if
div(w) ≤ k. We first establish that a string with large divergence must have a large forkable
substring. We then apply this in Theorem 4.31 below to conclude that characteristic strings arising
from πiSPoS (that is, for which each bit is a Bernoulli random variable) are unlikely to have large
divergence and, hence, possess the common prefix property. The specific fork of relevance, as
described above, is FA arising from the protocol; however, the analysis below will show that no
fork realizes large divergence.
We begin by identifying the substring w̌; the remainder of the proof is devoted to constructing
a flat fork for w̌ to establish forkability. Let y denote the last vertex on the tine t1 ∩ t2 , as in the
diagram below, and let α , `(y) = `(t1 ∩ t2 ).
Let β denote the smallest honest index of w for which β ≥ `(t2 ), with the convention that if there
is no such index we define β = n + 1. It follows that `(t1 ) < β. Specifically, if `(t1 ) = `(t2 ) = i then
this label i is adversarial and hence `(t1 ) < β; otherwise, either `(t1 ) < `(t2 ) ≤ β or β = n + 1 and
thus `(t1 ) < β.
These indices, α and β, distinguish the substring w̌ = wα+1 . . . wβ−1 which will be the subject
of the remainder of the proof. As the function `(·) is strictly increasing along any tine, observe that
|w̌| = β − α − 1 ≥ `(t1 ) − `(y) ≥ length(t1 ) − length(t1 ∩ t2 ) = div(w) ,
so w̌ has the desired length and it suffices to establish that it is forkable.
We briefly summarize the proof before presenting the details. We begin by establishing several
structural properties of the tines t1 and t2 that follow from the assumptions (12) and (13) above.
To establish that w̌ is forkable we then extract from F a flat fork (for w̌) in two steps: (i.) the fork
F is subjected to some minor restructuring to ensure that all “long” tines pass through y; (ii.) a
flat fork is constructed by treating the vertex y as the root of a portion of the subtree of F labeled
with indices of w̌. At the conclusion of the construction, segments of the two tines t1 and t2 will
yield the required “long, disjoint” tines satisfying the definition of forkable.
We observe, first of all, that the vertex y cannot be adversarial: otherwise it is easy to construct
an alternative fork F̃ ` w and a pair of tines in F̃ that achieve larger divergence. Specifically,
construct F̃ from F by adding a new (adversarial) vertex ỹ to F for which `(ỹ) = `(y), adding an
edge to ỹ from the vertex preceding y, and replacing the edge of t1 following y with one from ỹ; then
the other relevant properties of the fork are maintained, but t1 /t2 —and hence the divergence—of
the resulting tines has increased by one. (See the diagram below.)
A similar argument implies that the fork F0 ` w1 . . . wα obtained by including only those vertices
of F with labels less than or equal to α = `(y) has a unique vertex of depth depth(y) (namely, y
itself). In the presence of another vertex ỹ (of F0 ) with depth depth(y), “redirecting” t1 through
ỹ (as in the argument above) would likewise result in a fork with larger divergence. Note that `(·)
would indeed be increasing along this new tine (resulting from redirecting t1 ) because `(ỹ) ≤ `(y)
according to the definition of F0 . As α is the last index of the string, this additionally implies that
F0 has no vertices of depth exceeding depth(y).
We remark that the minimality assumption (13) implies that any honest index h for which
h < β has depth no more than min(length(t1 ), length(t2 ).
To see this, consider an honest index h < β and the tine th for which `(th ) = h. Recall that t1
and t2 are viable; as h < `(t2 ) it follows immediately that d(h) ≤ length(t2 ). Similarly, if h ≤ `(t1 )
then d(h) ≤ length(t1 ), so it remains to settle the case when `(t1 ) < h < `(t2 ): in particular, in
this regime we wish to likewise guarantee that d(h) ≤ length(t1 ). For the sake of contradiction,
assume that length(th ) = d(h) > length(t1 ). Considering the tine th , we separately investigate
two cases depending on whether th shares an edge with t1 after the vertex y. If, indeed, th and t1
share an edge after the vertex y then th and t2 do not share such an edge, and we observe that
div(w) ≥ th /t2 ≥ t1 /t2 = div(w) (and hence div(w) = div(th , t2 )) while |`(t2 ) − h| < |`(t2 ) − `(t1 )|
which contradicts (13). If, on the other hand, th shares no edge with t1 after y, we similarly observe
that div(w) ≥ t1 /th ≥ t1 /t2 = div(w) while |h − `(t1 )| < |`(t2 ) − `(t1 )|, which contradicts (13).
In light of the remarks above, we observe that the fork F may be “pinched” at y to yield an
essentially identical fork F ByC ` w with the exception that all tines of length exceeding depth(y)
pass through the vertex y. Specifically, the fork F ByC ` w is defined to be the graph obtained
from F by changing every edge of F directed towards a vertex of depth depth(y) + 1 so that it
originates from y. To see that the resulting tree is a well-defined fork, it suffices to check that `(·)
is still increasing along all tines of F ByC . For this purpose, consider the effect of this pinching on
an individual tine t terminating at a particular vertex v—it is replaced with a tine tByC defined so
that:
If length(t) ≤ depth(y), the tine t is unchanged: tByC = t.
Otherwise, length(t) > depth(y) and t has a vertex z of depth depth(y) + 1; note that
`(z) > `(y) because F0 contains no vertices of depth exceeding depth(y). Then tByC is
defined to be the path given by the tine terminating at y, a (new) edge from y to z, and the
suffix of t beginning at z. (As `(z) > `(y) this has the increasing label property.)
Thus the tree F ByC is a legal fork on the same vertex set; note that depths of vertices in F and
F ByC are identical.
By excising the tree rooted at y from this pinched fork F ByC we may extract a fork for the
string wα+1 . . . wn . Specifically, consider the induced subgraph F yC of F ByC given by the vertices
{y} ∪ {z | depth(z) > depth(y)}. By treating y as a root vertex and suitably defining the labels
`yC of F yC so that `yC (z) = `(z) − `(y), this subgraph has the defining properties of a fork forwα+1 . . . wn . In particular, considering that α is honest it follows that each honest index h > α has
depth d(h) > length(y) and hence labels a vertex in F yC . For a tine t of F ByC , we let tyC denote
the suffix of this tine beginning at y, which forms a tine in F yC . (If length(t) ≤ depth(y), we define
Proof. Recall that the FLS [FDSIG ] functionality directly provides a leader selection schedule and—
for any adversarial selection of corrupted players with total stake (1/2 − )—yields a characteristic
string w = w1 , . . . , wL where each wi is selected independently and E[wi ] = 1/2 − . Recall that we have the luxury of an ideal signature scheme and, furthermore, the probability—taken across all evaluations of the hash function by all participants of the protocol including the adversary—that a collision is observed is no more than H (q) , q 2 /|Range|,
where q is the total number of queries to the hash function and |Range| is the size of the range
of the function.
In light of these properties, unless there is an (unlikely) collision among the queries to the hash
function, the adopted chains form a well-defined fork FA ` w. We observe that if w satisfies cp, hcg,
and ∃cq, the execution E satisfies CP, HCG, and ∃CQ with the same parameters. (It is possible,
of course, that the execution E actually satisfies these properties with stronger parameters, as the
execution yields a specific fork (FA ) while the abstract quantities cp, cg, and ∃cq for w are worst
case estimates taken over all forks.)
We observe that a violation of persistence would imply directly a violation of k-CP. 
Now regarding liveness with parameter u = 2(k + `), we observe that it is implied by (1/2, 2k)HCG and `-∃CQ. Specifically, consider a transaction tx being provided as part of input data for a
period S of u slots. Let t be any viable tine that spans S. In light of `-∃CQ, t contains an honestly
generated block associated with a slot sl1 among the first ` slots of S and—as tx was available to
the honest party generating this block—it must appear in t[0, sl1 ]. Similarly, an honest block must
be associated with a slot sl2 among the last ` slots of S. As u = 2(k + `), sl2 ≥ sl1 + 2k and, as a
consequence of (1/2, 2k)-HCG, the tine t contains at least k blocks after sl1 (but indexed by slots
in S); specifically, length(t(sl1 , sl2 ]) ≥ k. This guarantees u-liveness. 
In the static version of the protocol in the previous section, we assumed that stake was static during
the whole execution (i.e., one epoch), meaning that stake changing hands inside a given epoch does
not affect leader election. Now we put forth a modification of protocol πSPoS that can be executed
over multiple epochs in such a way that each epoch’s leader election process is parameterized by
the stake distribution at a certain designated point of the previous epoch, allowing for change in
the stake distribution across epochs to affect the leader election process. As before, we construct
the protocol in a hybrid model, enhancing the FLS ideal functionality to now provide randomness
and auxiliary information for the leader election process throughout the epochs (the enhanced
functionality will be called FDLS ). We then discuss how to implement FDLS using only FLS and in
this way reduce the assumption back to the simple common random string selected at setup.
Before describing the protocol for the case of dynamic stake, we need to explain the modification
of FLS so that multiple epochs are considered. The resulting functionality, FDLS , allows stakeholders
to query it for the leader selection data specific to each epoch. FDLS is parameterized by the initial
stake of each stakeholder before the first epoch e1 starts; in subsequent epochs, parties will take into
consideration the stake distribution in the latest block of the previous epoch’s first R −k 0 slots (k 0 is
parameter we set below). Given that there is no predetermined view of the stakeholder distribution,
the functionality FDLS will provide only a random string and will leave the interpretation according
to the stakeholder distribution to the party that is calling it. The effective stakeholder distribution
is the sequence S1 , S2 , . . . defined as follows: S1 is the initial stakeholder distribution; for slots
{(j − 1)R + 1, . . . , jR} for j ≥ 2 the effective stakeholder Sj is determined by the stake allocation
that is found in the latest block with timestamp less than (j − 1)R − k 0 , provided all honest parties
agree on it, or is undefined if the honest parties disagree on it. The functionality FDLS is defined
in Figure 9. For maximum flexibility, and to anticipate the needs of the next phase of our analysis,
we allow the adversary to perform a lookahead on the beacon value for E ≥ 0 slots prior to the
onset of the epoch. To account for this lookahead the value of k 0 must be suitably adjusted; see
below.
FDLS incorporates the diffuse and key/transaction functionality from Section 2 and is parameterized by the public keys and respective stakes of the initial (before epoch e1 starts) stakeholders
S0 = {(vk1 , s01 ), . . . , (vkn , s0n )} a distribution D and a leader selection function F. In addition, FDLS
operates as follows:
Genesis Block Generation Upon receiving (genblock req, Ui ) from stakeholder Ui it operates
as functionality FLS on that message.
Signature Key Pair Generation It operates as functionality FLS .
Epoch Randomness Update Upon receiving (epochrnd req, Ui , ej ) from stakeholder Ui , if j ≥ 2
is the current epoch, FDLS proceeds as follows. If ρj has not been set, FDLS samples ρj ← D.
Then, FDLS sends (epochrnd, ρj ) to Ui . The adversary is allowed a lookahead of E ≥ 0 slots to
this interface where E is a parameter of the functionality.
We now describe protocol πDPoS , which is a modified version of πSPoS that updates its genesis
block data (and thus the leader selection process) for every new epoch. The protocol also adopts
an adaptation of the static maxvalidS function, defined so that it narrows selection to those chains
which share common prefix. Specifically, it adopts the following rule, parameterized by a prefix
length k:
Function maxvalidk (C, C) Returns the longest chain from C ∪ {C} that does not fork
from C more than k blocks. If multiple exist it returns C, if this is one of them, or it
returns the one that is listed first in C.
As a matter of notation, we simply refer to this rule as maxvalid() when the parameter can be
inferred from context.
Protocol πDPoS is described in Figure 10 and functions in the FDLS -hybrid model. We also define
an idealised version of this protocol πiDPoS for which it holds that access to the digital signature is
performed via the interface of FDSIG .
Protocol πDPoS ; with parameters k, `, E, R, L satisfying 2(k + `) + E ≤ R.
πDPoS is a protocol run by a set of stakeholders, initially equal to U1 , . . . , Un , interacting with FDLS over
a sequence of L slots S = {1, . . . , L} divided in epochs of length R < L. πDPoS proceeds as follows:
Initialization Stakeholder Ui ∈ {U1 , . . . , Un }, receives from the key registration interface its
public and secret key. Then it receives the current slot from the diffuse interface and in case it
is sl1 it sends (genblock req, Ui ) to FLS , receiving (genblock, S0 , ρ, F) as the answer. Ui sets the
local blockchain C = B0 = (S0 , ρ) and the initial internal state st = H(B0 ). Otherwise, it receives
from the key registration interface the initial chain C, sets the local blockchain as C and the initial
internal state st = H(head(C)).
Chain Extension For every slot sl ∈ S, every online stakeholder Ui performs the following steps:
If a new epoch ej , with j ≥ 2, has started, Ui defines Sj to be the stakeholder distribution
drawn from the most recent block with timestamp less or equal to (j − 1)R − 2(k + `) − E
where E ≥ 0 is the lookahead the adversary is allowed on the beacon and sends
(epochrnd req, Ui , ej ) to FLS , receiving (epochrnd, ρj ) as answer.
Collect all valid chains received via broadcast into a set C, verifying that for every chain
C 0 ∈ C and every block B 0 = (st0 , d0 , sl0 , σ 0 ) ∈ C 0 it holds that Vrf vk0 (σ 0 , (st0 , d0 , sl0 )) = 1, where
0
vk0 is the verification key of the stakeholder U 0 = F(Sj 0 , ρj , sl0 ) with ej 0 being the epoch in
which the block B 0 belongs (as determined by sl0 ). Ui computes C 0 = maxvalid(C, C), sets C 0
as the new local chain and sets state st = H(head(C 0 )).
(c) If Ui is the slot leader determined by F(Sj , ρj , sl) in the current epoch ej , it generates
a new block B = (st, d, sl, σ) where st is its current state, d ∈ {0, 1}∗ is the data and
σ = Signski (st, d, sl) is a signature on (st, d, sl). Ui computes C 0 = C|B, broadcasts C 0 , sets
C 0 as the new local chain and sets state st = H(head(C 0 )).
Remark 1. The modification to maxvalid(·) to not diverge more than k blocks from the last chain
possessed will require stakeholders to be online at least every k slots. The relevance of the rule
comes from the fact that as stake shifts over time, it will be feasible for the adversary to corrupt
stakeholders that used to possess a stake majority at some point without triggering Bad /2−δ and
thus any adversarial chains produced due to such an event should be rejected.
We are now ready to state the main result of the section that establishes that the πDPOS protocol
is a robust transaction ledger under the environmental conditions that we have assumed. Recall
that in the dynamic stake case we have to ensure that the adversary cannot exploit the way stake
changes over time and corrupt a set of stakeholders that will enable the control of the majority of
an elected committee of stakeholders in an epoch. In order to capture this dependency on stake
“shifts,” we introduce the following property.
Definition 5.2 (Stake shift). Consider two slots sl1 , sl2 and an execution E. The stake shift between
sl1 and sl2 is the maximum statistical distance, taken over all chains C adopted by an honest party,
of the two weighted-by-stake distributions that are defined by C[0 : sl1 ] and C[0 : sl2 ].
With this definition in place we are ready to state the main theorem.
Theorem 5.3. Fix parameters k, `, , σ, E, R, and L, where R ≥ 2(k + `) + E and L is an
integer multiple of R. Consider an execution E of πiDPoS with lifetime L coupled with a (1/2 − )initially-bounded adversary A with corruption delay D = R + E + 2(k + `) and beacon lookahead
E and environment Z exhibiting a stake-shift of no more than σ over any period of ` slots.  The most important family of
random variables capture the high-level chain properties of the protocol:
Chain guarantees. We remark, by reasoning parallel to that of Theorem 4.32, that these properties directly imply
CG with parameters (k/(2k + 2`), 2(k + `)). (In particular, this guarantees growth of k blocks
over any period of 2(k + `) slots.)
For convenience, we adopt the convention that Chain0 occurs by fiat.
We continue to define a number of ancillary random variables which only take on relevant values
in case Chaint occurs.
Instantaneous common prefix. When Chaint occurs, the chains adopted by the family of honest
players at the outset of slot tR share a common prefix through slot tR − 2(k + `); we let C (t)
denote this common chain. This follows directly from the chain properties discussed above,
which guarantee k-CP and growth of k blocks over any window of 2(k + `) slots.
The analysis below critically relies on the property that C (t) is immutable: specifically, when
Chaint occurs all honest participants agree on C (t) and, as maxvalidk can only revise the last
k blocks of a currently adopted chain, C (t) will be a prefix of all future chains held by the
honest parties.
If Chaint does not occur, we define C (t) = ⊥.
Instantaneous stake distribution; instantaneous characteristic string. S1 is defined by the
genesis block. For each t > 1, we define St to be the stake distribution determined by C (t−1)
if Chaint−1 occurs; otherwise, we set St = ⊥.
For each t, we define a random variable w(t) ∈ {0, 1}R ∪ {⊥R } so that:
If Chaint−1 occurs, then w(t) is the characteristic string associated with epoch t. More
precisely, this is the characteristic string defined by the leader election schedule determined by stake distribution St and the beacon ρt , and the set of parties corrupted.
For later convenience, we also identify the random variables Hont which indicate if a
majority of slots in epoch t are honest (which is to say that the Hamming weight of
w(t) is strictly less than R/2).
We use the word “instantaneous” above to emphasize that these random variables are defined by
the state of the protocol at a particular time slot, and that the various features they describe (e.g.,
stake distributions, chains, etc.) evolve over the future course of the protocol.
We note some critical properties of these random variables.
First of all, considering that Chaint ⇒ Chains for all s ≤ t, the occurrence of Chaint implies that
a variety of protocol data established during these epochs persists through the rest of the protocol.
Specifically, C (1)  · · ·  C (t) and, more generally, each C (s) is a prefix of the chains adopted by all
honest parties during epochs s + 1, s + 2, . . .. As a result, the honest parties unanimously agree on
the stake distribution Ss , for each 1 ≤ s ≤ t + 1, both at the end of the epoch in which they are
defined and throughout the rest of the protocol.Continuing to discuss the ramifications of Chaint , the fact that the honest parties agree on
S1 , . . . , St+1 and, of course, agree on the beacon values, yields persistent agreement on the leader
schedules for the first t + 1 epochs. As a matter of analysis, we remark that Chaint thus unambiguously defines the characteristic string w = w(1) . . . w(t+1) and a fork FAt+1 ` w associated with all
chains adopted by honest parties. Note, in particular, the graph structure of FAt+1 is simply defined
by the unambiguous leader schedules, the structure of the chains held by honest players, the fact
that no collisions are observed by the hash function, and the ideal signature scheme. To check
that FAt+1 ` w, it suffices to ensure that any slot behaving adversarially vis-a-vis the structure of
the fork—for example, violating the longest chain rule or generating multiple blocks—is correctly
reflected by the definition of w. Note, however, that a block signed by the leader of slot i (and
associated with slot number i) can only be adopted by an honest player during the next 2(k + `)
slots, as this is sufficient time for any player to accumulate a chain of length k beyond which no
alteration to slot i is possible. As w surely identifies a slot as adversarial if the leader will be under
adversarial control during the following 2(k + `) slots, this definition of w supports the fork FAt+1 ,
as desired.
We shift our attention to the distribution determined on w. Conditioned on Chaint , as noted
above, the stake distribution St+1 is unambiguously determined by C (t) [0 : Rt − 2(k + `) − E] (cf.
part (a) of the Chain Extension step of Figure 10). As of slot Rt − E, when the beacon is exposed
to the adversary, this chain is stable in the view of all honest parties; that is—applying `-∃CQ and
(1/2, 2k)-HCG as above—any honest party has added at least k blocks to the chain so that it will
exist as a prefix of all honest parties’ chains for the remainder of the protocol. It follows that the
beacon value ρt+1 is independent of St+1 . Consider now the adversarial stake distribution indicated
by C[0 : Rt − E − 2(k + `)]. As the last block of this chain might not be honestly generated, we
cannot directly apply the guarantee provided by Bad /2−−σ to this distribution; however, in light
of `-∃CQ, there is an honestly generated block on C appearing no more than ` slots beyond the last
block of C[0 : Rt − E − 2(k + `)] so that, recalling the guarantee of σ stake shift over any ` slots,
the adversarial stake ratio given by C[0 : Rt − E − 2(k + `)] is no more than 1/2 − .
To complete the proof, consider the “virtual characteristic string” x obtained by substituting
all ⊥ in w = w(1) . . . w(L/R) with 0. Note that if Chaint fails for some t, the string w—and hence
the string x—must violate k-cp, `-∃cq, or (1/2, 2k)-HCG. Observe, also, that the string x, taking
values in {0, 1}L has the property that for each t
Pr[xi = 1 | x1 , . . . , xi−1 ] ≤ 1/2 − 
and hence, by Lemma 4.18, that the random variable x is stochastically dominated by the random
variable b = b1 . . . , bL ∈ {0, 1}L given by independently assigning each bi = 1 with probability
exactly 1/2 − . The event that a characteristic string violates k-cp, `-∃cq, or (1/2, 2s)-cg is clearly
monotone, as any violation is preserved by monotonically increasing the set of adversarial slots. We
remark, additionally, that if a characteristic string satisfies k-cp then, for any z ≥ 2k, the Hamming
weight of the string is less than z/2 over any interval of z slots (otherwise there is an immediate
k-cp violation). In light of Lemma 4.19, Lemma 4.22, and Theorem 4.31, it follows that
Pr[x violates k-cp, `-∃cq, or (1/2, 2k)-cg] ≤ Pr[b violates k-cp, `-∃cq, and (1/2, 2k)-cg]To conclude, observe that if x satisfies k-cp, s-∃cq, and (1/2, 2s)-cg, then Chaint holds for all t and
hence w = x. In light of the comment above, in this case Hont is also satisfied for all t. It follows,
in this case, that E satisfies k-CP, `-∃CQ, and (1/2, 2k)-CG, as desired.
These properties imply persistence with parameter k and liveness with parameter u = 2(k + `).
Liveness and persistence for πDPoS . We observe now that Proposition 5.1 and Theorem 5.3
can be combined to show the security of protocol πDPoS in the setting of a trusted beacon: in
particular, if there is an attack against persistence or liveness against πDPoS , it can be transformed
to an attack against πiDPoS . It follows that πDPoS possesses the same liveness and persistence
properties as πiDPoS , with an extra error term to account for failure of the signature scheme. We
omit further details as we turn our focus to the final protocol, where we show how the beacon can
be implemented.
While protocol πDPoS handles multiple epochs and takes into consideration changes in the stake
distribution, it still relies on FDLS to perform the leader selection process. In this section, we show
how to remove the dependency to FDLS through a Protocol πDLS , which allows the stakeholders to
compute the randomness and auxiliary information necessary in the leader election. The resulting
modified protocol that we will denote Π[πDPoS , πDLS ] operates in the FLS hybrid world.
Recall that the only essential difference between FLS and FDLS is the continuous generation of
random strings ρ2 , ρ3 , . . . for epochs e2 , e3 , . . .. The idea is simple: protocol πDLS will use a coin
tossing protocol to generate unbiased randomness that can be used to define the values ρj , j ≥ 2
bootstrapping on the initial random string and initial honest stakeholder distribution. However,
notice that the adversary could cause a simple coin tossing protocol to fail by aborting. Thus, we
build a coin tossing scheme with “guaranteed output delivery.”
Protocol πDLS is described in Figure 12 and uses a publicly verifiable secret sharing (PVSS) [44].
The resulting combined protocol Π[πDPoS , πDLS ] operates as πDPoS while it runs πDLS to support the
random beacon generation for each epoch. For simplicity we will describe the combined protocol in
the random oracle model, i.e., with access to a random oracle functionality FRO ; nevertheless, it is
also possible to achieve alternative realisations that do not depend on the random oracle abstraction.
We will take advantage of a simulation argument that will exploit the fact that the PVSS scheme and
the coin-flipping protocol built on top of it simulates a perfect beacon with negligible distinguishing
advantage. Simulation here suggests that, in the case of honest majority, there is a simulator that
interacts with the adversary and produces indistinguishable protocol transcripts when given the
beacon value after the commitment stage. While describing such a simulator is outside the scope of
our exposition, such a simulator can be inferred from the PVSS schemes of [44] or [18] realized in
the random oracle model where one can take advantage of programmability of the oracle. We note
that a random oracle is by no means necessary and it is possible to derive a simulator by taking
advantage of a “common reference string” (CRS) embedded into the genesis block.
Commitments and Coin Tossing. A coin tossing protocol allows two or more parties to obtain
a uniformly random string. A classic approach to construct such a protocol is by using commitment
schemes. In a commitment scheme, a committer carries out a commitment phase, which sends
evidence of a given value to a receiver without revealing it; later on, in an opening phase, the
committer can send that value to the receiver and convince it that the value is identical to the
value committed to in the commitment phase. Such a scheme is called binding if it is hard forthe committer to convince the receiver that he was committed to any value other than the one for
which he sent evidence in the commitment phase, and it is called hiding if it is hard for the receiver
to learn anything about the value before the opening phase. We denote the commitment phase
with randomness r and message m by Com(r, m) and the opening as Open(r, m).
In a standard two-party coin tossing protocol [11], one party starts by sampling a uniformly
random string u1 and sending Com(r, u1 ). Next, the other party sends another uniformly random
string u2 in the clear. Finally, the first party opens u1 by sending Open(r, u1 ,) and both parties
compute output u = u1 ⊕ u2 . Note, however, that in this classical protocol the committer may
selectively choose to “abort” the protocol (by not opening the commitment) once he observes the
value u2 . While this is an intrinsic problem of the two-party setting, we can avoid this problem
in the multi-party setting by relying on a verifiable secret sharing scheme and an honest majority
amongst the protocol participants.
Publicly Verifiable Secret Sharing (VSS). A secret sharing scheme allows a dealer PD to
split a secret σ into n shares distributed to parties P1 , . . . , Pn , such that no adversary corrupting up
to t parties can recover σ. In a Verifiable Secret Sharing (VSS) scheme [26], there is the additional
guarantee that the honest parties can recover σ even if the adversary corrupts the shares held by
the parties that it controls and even if the dealer itself is malicious. We define a VSS scheme as a
pair of efficient dealing and reconstruction algorithms (Deal, Rec). We are only interested in VSS
where the secret is a random string. The dealing algorithm Deal(t, n) takes as input the number of
shares to be generated n as well as a parameter t ≤ n and outputs shares σ1 , . . . , σn of a random
value σ. The reconstruction algorithm Rec takes as input shares σ1 , . . . , σn and outputs the secret
σ as long as no more than t shares are corrupted (unavailable shares are set to ⊥ and considered
corrupted). A publicly verifiable secret sharing scheme allows any third party to verify the validity
of the shares in a non-interactive way without learning the shares themselves. This is achieved by
publishing auxiliary verification information that can later be attested to correspond to the shares
when those are revealed. Specifically, there is a Setup algorithm which is assumed to be executed
honestly, a key generation algorithm KeyGen that is executed by each shareholder resulting in a
secret and a public-key, as well as having an encryption for each σi , denoted by βi , from which σi is
recoverable via the secret-key of the i-th stakeholder by running algorithm Decrypt. Finally, a Verify
algorithm is capable of verifying all encrypted shares using the public-key and setup information.
We refer to the discrete logarithm based PVSS of [44] or [18] for more details.
Constructing Protocol πDLS . The main problem to be solved when realizing FDLS with a
protocol run by the stakeholders is that of generating uniform randomness for the leader selection
process while tolerating adversaries that may try to interfere by aborting or feeding incorrect
information to parties. In order to generate uniform randomness ρj for epoch ej , j ≥ 2, the elected
stakeholders for epoch ej−1 will employ a coin tossing scheme for which all honest parties are
guaranteed to receive output as long as there is an honest majority. The protocol has two stages,
commit and reveal, and it employs two parameters k, `. The stages of the protocol are presented
in Figure 11.
The commitment phase, consisting of 2k + 3` slots, proceeds as follows: for 1 ≤ i ≤ R, stakeholder Ui engages in PVSS by executing Deal(R, R/2) and posts the output shares to the blockchain.
Later, 2k + 3` slots after the beginning of the commitment phase, players check whether their
blockchain up to slot ` of the commitment phase contains proper PVSS shares from at least R/2 + 1
of the selected stakeholders; this requires running the PVSS verification for each commitment. Figure 11: The stages of the protocol πDPoS that use the blockchain as a broadcast channel in an
epoch of R ≥ 2k + 4` slots.

slots, for 1 ≤ i ≤ R, stakeholder Ui reveals the share it received for each commitment, cf. Protocol
πDLS in Figure 12. We remark that it is possible, at the expense of expanding the length of an
epoch somewhat more, to run a more efficient opening stage first and then “force-open” only those
commitments that were kept private. Given that, optimistically, no force-open will be required, the
overall communication complexity in this case would improve.
As a prelude to the next section, we will show how πDLS protocol implements the FDLS functionality based on the FLS functionality and a “bulletin board” FBB . Specifically, the functionality
operates as follows: it is parameterized by k, ` and a stakeholder distribution S0 . Whenever one of
the stakeholders submits a message m this is passed to the adversary and after ` slots it is reported
as pending to any party querying the bulletin board. Finally after 2(k + `) slots, all pending messages submitted before 2(k + `) slots are finalized in some slot selected by the adversary and are
reported to any party querying the functionality together with a slot they are finalised in, which
can be anywhere from 1 up to ` slots later than the the slot they were originally submitted. Below
we use FBB as a global functionality, cf. [17].


are computationally indistinguishable under the Computational Diffie Hellman assumption where
the lookahead parameter of FDLS is set to E = `.
Proof. Fixing any A, the simulator S runs A and controls the honest parties’ postings with respect
to the underlying πDLS protocol following the round structure of the protocol. We recall here the
structure of the PVSS protocol of [44]. There are public parameters g, G and each party has a
registered public-key of the form yi = Gxi . To make a commitment each party picks a random
polynomial p(·) of degree d = R/2 with coefficients a0 , a1 , . . . , ad . Using a proof of equality of discrete logarithms the party also publishes
for each i, a proof that logg (Xi ) = logyi (Yi ). A commitment is verified by checking all proofs of
discrete-log equality. Note that a commitment may be opened by publishing S = Ga0 together
with a proof of equality of discrete logarithms logG (S) = logg (C0 ). The hash of the product of
opened commitments is the value of the next beacon. The parties “force” open the commitments
x−1

of each other by publishing the values: (i, Si ) with Si = Yi i ) together with a proof of equality of
discrete-logarithms logSi (Yi ) = logYi (G).We next describe a simulated execution of the protocol that is based on a DDH tuple hg, G, C, Di.
During the initial commit stage, S follows the protocol of each honest party modifying the commitment C0 to be computed as C a0 as opposed to g a0 . For simplicity, assume that the adversarial
parties are 1, . . . , R/2. In the simulated execution, the public-keys yR/2+1 , . . . , yR are selected as
powers of g. The polynomial values p(1), . . . , p(R/2) are selected on behalf of the honest party
at random. Subsequently, the share encryptions y1 , . . . , yR/2
are calculated. Note that the
values p(R/2 + 1), . . . , p(R) cannot be evaluated directly since the value p(0) is determined by
logg (C0 ) = a0 · logg C which is unknown to the simulator. Specifically, the simulator can calculate g p(R/2)+1 , . . . , g p(R) by a suitable Lagrange interpolation over the bases: g p(1) , . . . , g p(R/2) , C a0 = g p(0) and then, by raising them
to the corresponding honest party secret-keys, the simulator obtains YR/2+1 , . . . , YR . In a similar
manner the values C1 = g a1 , . . . , Cd = g ad can be calculated by Lagrange interpolation with the
bases g p(1) , . . . , g p(R/2) , C a0 = g p(0) . All proofs performed by S on behalf of the honest party will
be simulated taking advantage of random oracle programmability.
Observe that the PVSS opening for the honest party is equal to Da0 . S follows the above
strategy for all honest parties while it receives all the PVSS values contributed by the malicious
party. At the conclusion of the 2(k + `) round, S queries FDLS to obtain the beacon value of the
next epoch. At this moment S is ready to program the random oracle so that the next epoch is
fixed to the correct beacon value; we call this the critical moment of the simulation. Note that
programmability will be achievable provided that the value Da0 for a PVSS of an honest party can
be set to a desired random value; if this value is already defined then S fails. Assuming the failure
event does not happen, given that S controls a majority of parties, it is capable of extracting the
PVSS value contributed by each malicious party; note that this requires the proper secret-key of
the honest party, which in turn requires logg (G).
Next we argue that the failure event happens with negligible probability. For the sake of
contradiction suppose that it happens with some probability α which is non-negligible. We perform
the simulation as above setting the values hg, G, Ci to a given instance of the CDH problem for a
random honest party. Subsequently at the critical moment of the simulation we terminate returning
as output the value X 1/a0 where X is a random input value in the random oracle table. Given that
the failure event happens with probability α, we conclude that this algorithm breaks CDH with
probability α/(Rq) where is q is the number of queries posed to the random oracle.
The key idea is to combine the πDLS protocol and its ability to simulate FDLS as shown in Proposition 5.4 with the recursive argument of Theorem 5.3 observing that the blockchain itself can play
the role of the FBB that πDLS requires. The resulting combined protocol Π[πDPoS , πDLS ] executes
both operations of πDPoS and πDLS in this order in each slot while it queues any messages to be
transmitted for diffusion by either protocol and transmits them at the end of each slot.
We assume that the Setup algorithm for the PVSS has been executed and its output
is posted in FBB as well as each stakeholder Ui has performed KeyGen to obtain yi , si and posted the
public-key yi to FBB . (If some of the stakeholders’ keys are missing the same protocol is executed with
R adjusted accordingly).
Commitment Phase (2k + 3` slots) At slot R − 2k − 4` of epoch ej , for 1 ≤ i ≤ R, stakeholder
Ui performs Deal(R, R/2, y1 , . . . , yR ) to obtain the encryptions β1 , . . . , βn and posts them to FBB .
Reveal Phase (` slots) At slot R − ` of epoch ej , for 1 ≤ i ≤ R, Ui runs Decrypt(si , βli ) to recover
the encrypted shares σli for any Ul that successfully posted in FBB R encrypted shares that verify
correctly (i.e., pass Verify) and were finalized in FBB during the first ` slots of the commitment
phase. Subsequently it posts σli to the FBB .
The implementation of epochrnd req is then as follows.
Given input (epochrnd req, Ui , ej ) , the values ρjl are calculated to be equal to H(Rec(σl1 , . . . , σlR ))
assuming that Ul posted to FBB all shares correctly (otherwise ρjl is set to 0). 
Here H denotes the probability of a collision occurring among the queries to H (including those of
A), DSIG is the distinguishing advantage of the digital signature implementation, DLS is the dis1
tance of the DSIG implementation. The above probabilities are in the conditional space ¬Bad /2−−σ .
Proof. Fix some environment Z and adversary A. As before we first consider the execution E
of Π[πiDPoS , πDLS ]. We consider now a modified execution E ∗ where the execution of the πDLS
protocol is substituted by the simulation that is provided due to Proposition 5.4. In this modified
execution E ∗ we define the same set of random variables Chain∗t and C ∗(t) , Hon∗t for each epoch t as
in the proof of Theorem 5.3. The stakeholder distribution for each beacon simulation that samples
the beacon for the next epoch is drawn from the immutable chain C ∗(t) .
The simulation might stop for two reasons. First it might be the case that the chain C ∗(t) = ⊥,
i.e., the immutable chain of the stakeholders is not defined and hence no stakeholder distribution
can be determined to execute the beacon protocol. The second case where it might fail is because
of a dishonest majority among the R selected stakeholders, i.e., Hont = 0.

Now consider the event B that either persistence or liveness is violated in an execution E of the
protocol Π[πiDPoS , πDLS ] and let t̃ be the index of the earliest epoch that this takes place (or t̃ = ∞if the event never happens). We define the intermediate hybrid distributions between E and E ∗
denoted by E (t) for which it holds that the beacon generation in the first t epochs is performed in
simulation as in E ∗ while the remaining are performed as in E by performing πDLS . Observe that
E (0) = E and E (L/R) = E ∗ . Furthermore, conditional on 1 ≤ t < t̃, it holds that the computational
distance between E (t−1) and E (t) is at most DLS. 
Armed with this result, and using proposition 5.1 we can infer that there is a simulator S1 that
idealises the digital signature used in the protocol and acts as the attacker in an execution E.
From the above it follows immediately that persistence and liveness are violated in an execution of
Π[πDPoS , πDLS ] with the probability stated in the theorem.
Remark 2. We note that it is easy to extend the adversarial model to include fail-stop (and recover)
corruptions in addition to Byzantine corruptions. The advantage of this mixed corruption setting,
is that it is feasible to prove that we can tolerate a large number of fail-stop corruptions (arbitrarily
above 50%). The intuition behind this is simple: the forkable string analysis still applies even if
an arbitrary percentage of slot leaders is rendered inactive. The only necessary provision for this
would be expand the parameter k inverse proportionally to the rate of non-stopped parties; if the
rate is constant asymptotically the same analysis would apply. For a further investigation in this
direction see the follow up work, Ouroboros Genesis [4].
The general notion of fork defined in Definition 4.11 above reflects the possibility that adversarial
slot leaders may broadcast multiple blocks for a single slot; such adversaries may simultaneously
extend many different chains. While this provides the adversary significant opportunities to interfere with the protocol, it leaves a suspicious “audit trail”—multiple signed blocks for the same
slot—which conspicuously deviates from the protocol.
This motivates our consideration of a restricted class of covert adversaries, who broadcast no
more than one block per slot. Such an adversary may still deviate from the protocol by extending short chains, but does not produce such suspicious evidence and hence its strategy is more
“deniable”: it can blame network delays for its actions.

Such an adversary yields a restricted notion of fork, defined below:
Definition 6.1. Let F ` w be a fork for a string w ∈ {0, 1}∗ . We say that F is covert if the
labeling ` : V → {0, 1, . . .} is injective. In particular, no adversarial index labels more than one
node.
Contrast this with a more general adversary that attempts to fork by signing two different blocks for the same
slot; such an adversary cannot merely blame the network for such a deviation.As in the general case, we define a notion of forkable string for such adversaries.
Definition 6.2. We say that a string w is covertly forkable if there is a flat covert fork F ` w.
Covert adversaries and forks have much simpler structure than general adversaries. In particular, a string is covertly forkable if and only if a majority of its indices are adversarial. This provides
an analogue of Proposition 4.27 for covertly forkable strings.
Proposition 6.3. A string w ∈ {0, 1}n is covertly forkable if and only if wt(w) ≥ n/2.
Proof. Let w be a covertly forkable string and F ` w a flat covert fork. As F is flat, there are
two edge disjoint tines, t1 and t2 , with length equal to height(F ) and it follows that the number
of vertices in F is at least 2 · height(F ) + 1. In this covert case the labeling function is injective,
and it follows that n ≥ 2 · height(F ). (Recall that the root vertex is labeled by 0, which is not an
index into w.) On the other hand, the height of F is at least the number of honest indices of w.
We conclude that the length of w is at least twice the number of honest indices, as desired.
If wt(w) ≥ n/2, we can produce a flat covert fork F ` w by placing all honest indices on a
common tine t1 and selecting length(t1 ) adversarial indices to form an edge-disjoint second tine
t2 .
As the structure of covertly forkable strings is so simple, an analogue of Theorem 4.24 for the
density of covertly forkable strings follows directly from standard large deviation bounds.

We revisit the notion of common prefix in the setting of covert adversaries. We define the covert
divergence of w to be the maximum divergence over all possible covert forks for w.
As in the setting with general adversaries, we wish to establish that a string with large covert
divergence must have a large covertly forkable substring. A direct analogue of Theorem 4.31 then
implies that characteristic strings arising from πiSPoS are unlikely to have large covert divergence
and, hence, possess the common prefix property against covert adversaries.
We record an analogue of Theorem 4.30 for covert adversaries.

Theorem 6.5. Let w ∈ {0, 1}∗ . Then there is a covertly forkable substring w̌ of w with |w̌| ≥
cdiv(w).
Proof. We are more brief, as portions of the proof have direct analogs in the proof of Theorem 4.30.
Consider a covert fork F ` w and a pair of viable tines (t1 , t2 ) of F for which `(t1 ) ≤ `(t2 ) and
t1 /t2 = cdiv(w); we assume, as in the proof of the general case, that this pair of tines minimizes
the quantity |`(t2 ) − `(t1 )| among all pairs with divergence equal to cdiv(w).
Let y denote the last vertex on the tine t1 ∩ t2 . In contrast to the setting with a general
adversary, it is not clear that y is honest and this motivates a slightly different choice for the
beginning of the string w̌: define α to be the largest honest index of w on the tine t1 ∩ t2 , with the
convention that α = 0 if there is no such index. As in the proof of Theorem 4.30, define β to be
the smallest honest index of w for which β ≥ `(t2 ), with the convention that β = n + 1 if there is
no such honest index. Then define w̌ = wα+1 . . . wβ−1 ; as in the proof of Theorem 4.30 it is easy
to confirm that |w̌| = (β − 1) − α ≥ `(t1 ) − `(t1 ∩ t2 ) ≥ cdiv(w). The remainder of the proof argues
that w is covertly forkable.
As in the proof of Theorem 4.30, the depth d(h) of any honest index h < β is no more
than min(length(t1 ), length(t2 )): if h ≤ `(t1 ) this follows directly from the definition of viability. Otherwise, `(t1 ) < h < `(t2 ) and we consider the tine th labeled with h: if length(th ) ≥
min(length(t1 ), length(t2 )) then the tine th , coupled with either t1 or t2 , would produce a pair
of tines with divergence no less than div(t1 , t2 ), but for which |`(·) − `(·)| is strictly less than
|`(t1 ) − `(t2 )|.
To complete the proof, we define an injective function i : H → A, where H denotes the set of
honest indices in {α + 1, . . . , β − 1} and A the complement—the set of adversarial indices of w̌. The
existence of such a function implies that |H| ≤ |A| and hence that w̌ is covertly forkable by the
criterion given in Proposition 6.3. Let A0 ⊂ A denote the set of adversarial indices of w̌ appearing
as a label on either of the two tines t1 and t2 . The function i is defined as follows: i(h), for an
honest index h ∈ H, is the smallest (adversarial) index of A0 which labels a vertex at depth equalto d(h). Assuming that this function is well-defined it is clearly injective, as labels cannot appear
on multiple vertices of a covert fork and depths of honest vertices are pairwise distinct.
To confirm that i(h) is well-defined, note that for any h ∈ H we must have d(α) < d(h) ≤
min(length(t1 ), length(t2 )) and hence there is at least one vertex v on each of t1 and t2 with depth
equal to d(h); furthermore, by the defining properties of α and β, this vertex is labeled with
an index of w̌. If d(h) ≤ length(t1 ∩ t2 ), there is a common vertex v on these tines for which
length(v) = d(h); note that this vertex cannot be honest by the definition of α, so i(h) = `(v) is
well-defined in this case. If d(h) > length(t1 ∩ t2 ), the two tines have distinct vertices at depth
d(h), and one of these must then be adversarial—thus i(h) is well-defined in this case as well.
Finally, we remark that the proof of Theorem 4.31 applies with minor adaptations to the covert
case.
Theorem 6.6. Let k, R ∈ N and  ∈ (0, 1/2). Let w = w1 . . . wR be drawn in {0, 1}R so that each
wi independently takes the value 1 with probability 1/2 − . Then
Pr[cdiv(w) ≥ k] ≤ R exp(−Ω(2 k)) .
This directly bounds the probability that a covert adversay can effect a common prefix violation in
an execution of πiSPoS.
The protocols constructed in the previous section are proven secure against delayed adaptive corruptions, meaning that, after requesting to corrupt a given party Ui , the adversary has to wait for
D slots before the corruption actually happens. Naturally, it is desirable to make D as small as
possible, or even eliminate it altogether to achieve security against a standard adaptive adversary.
The delay is required because the adversary must not be able to corrupt parties in direct response
to knowledge of the leader election schedule. (Recall that the protocol determines this schedule
on an epoch-by-epoch basis, so that such an attack would be particularly devastating.) However,
notice that the slot leaders are selected by weighting public keys by stake, while the adversary
can only choose to corrupt a user Ui without knowing its public key. Thus, the adversary must
be able to observe communication between Ui and the Diffuse functionality in order to determine
which public key is associated with user Ui and detect when Ui is selected as a slot leader. We will
show that we can eliminate the delay by extending our model with a sender anonymous broadcast
channel (provided by the Diffuse functionality) and having the environment activate all parties in
every round. We introduce the following modifications in the ideal functionalities:
• Diffuse Functionality: The functionality will work as described in Section 2 except that it
will remove all information about the sender Us of every message before delivering it to the
receiver Ur ’s inbox (input tape), thus ensuring that the sender remain anonymous.
In practice, a sender anonymous broadcast channel with properties akin to those of the Diffuse functionality can
be implemented by Mix-networks [19] or DC-networks [20] that can be executed by the nodes running the protocol. 
Key and Transaction Functionality: The functionality will work as described in Section 2 except that it will allow immediate corruption of a user U upon receiving a message (Corrupt, U )
from the adversary.
Apart from these modifications in the ideal functionalities, we also change the environment
behavior by requiring that it activates all users at every slot slj . Having all parties being activated
at every slot results in an anonymity set of size equal to the number of honest parties, making it
difficult for the adversary to associate a given public key with a user (i.e., any of the honest parties
could be associated with a given public key that is not associated with a corrupted party). In this
extended model we can reprove Theorem 5.5 without a delay D by strengthening the restrictions
that are imposed on the environment in the following way.
• We will say the adversary is restricted to less than 1/2 − δ relative stake for windows of length
D if for all
So far our analysis has focused on the cryptographic setting where a set of honest players operate
in the presence of an adversary who may corrupt some of the players. In this section we consider
the setting of a coalition of rational players and their incentives to deviate from honest protocol
operation.
In order to address incentives, we modify further our basic protocol to assign two different roles
to stakeholders. As before, in each epoch there is a set of elected stakeholders that are the slot
leaders of the epoch responsible for issuing blocks and forming the randomness of the next epoch.
Together with those there is a (not necessarily disjoint) set of stakeholders called the endorsers.
Now each slot has two types of stakeholders associated with it: the slot leader who will issue the
block as before and the slot endorser who will endorse the input to be included in the next slot.
(We remark that one can adapt this discussion to a setting with multiple endorsers; however, we
assume a single input endorser per slot in this description.) While this seems like an insignificant
modification it gives us a room for improvement for the following reason: endorsers’ contributions
will be acceptable even if they are d slots late, where d ∈ N is a parameter of the protocol. (In
particular, the protocol calls for slot leaders to include in their block any inputs endorsed by the
previous d endorsers and not appearing in the existing chain.) Note that blocks and endorsed
inputs are diffused independently with each block containing from 0 up to d endorsed inputs.
Note that in case no valid endorser input is available when the slot leader is about to issue
the block, the leader will go ahead and issue an empty block, i.e., a block without any actual
inputs (e.g., transactions in the case of a transaction ledger). Note that slot endorsers—just like
slot leaders—are selected by stake weight and are thus a representative sample of the stakeholder
population. In the case of a transaction ledger, the same transaction may be included by many input endorsers simultaneously. In case that a transaction is multiply present in the blockchain
its first occurrence only will be its “canonical” position in the ledger. The enhanced protocol,
πDPOSwE , can be easily seen to have the same persistence and liveness behaviour as πDPOS : the
modification with endorsers does not provide any possibility for the adversary to prevent the chain
from growing, accepting inputs, or being consistent. However, if we measure chain quality in terms
of number of endorsed inputs included this produces a more favorable result: it is easy to see that
the number of endorsed inputs originating from a set of stakeholders S in any k-long portion of
the chain is proportional to the relative stake of S with high probability. This stems from the fact
that it is sufficient that a single honest block is created for all the endorsed inputs of the last d
slots to be included in it. Assuming d ≥ ` (the ∃CQ parameter from previous sections), any set of
stakeholders S will be an endorser in a subset of the d slots with probability proportional to its
cumulative stake; the result follows.
As in bitcoin, stakeholders that issue blocks are incentivized to participate in the protocol
by collecting transaction fees. Contrary to bitcoin, of course, one does not need to incentivize
stakeholders to invest computational resources to issue blocks. Rather, availability and transaction
verification should be incentivized. Nevertheless, they have to be incentivized to be online often.
Any stakeholder, at minimum, must be online and operational in the following circumstances.
In the slot prior to a slot she is the elected shareholder so that she queries the network and
obtains the currently longest blockchain as well as any endorsed inputs to include in the block.
In the slot during which she is the elected shareholder so that she issues the block containing
the endorsed inputs.
In a slot during the commit stage of an epoch where she is supposed to issue the PVSS
commitment of her random string.
In a slot during the reveal stage of an epoch where she is supposed to issue the required
opening shares.
In general, in sufficient frequency, to check whether she is an elected shareholder for the next
or current epoch.
In a slot during which she is the elected input endorser so that she issues the endorsed input
(e.g., the set of transactions) that requires processing all available transactions and verifying
them.
In order to incentivize the above actions in the setting of a transaction ledger, fees can be
collected from those that issue transactions to be included in the ledger which can then be transfered
to the block issuers. In bitcoin, for instance, fees can be collected by the miner that produces a
block of transactions as a reward. In our setting, similarly, a reward can be given to the parties
that are issuing blocks and endorsing inputs. The reward mechanism does not have to be block
dependent as advocated in [38]. In our setting, it is possible to collect all fees of transactions
included in a sequence of blocks in a pool and then distribute that pool to all shareholders that
participated during these slots. For example, all input endorsers that were active may receive reward
proportional to the number of inputs they endorsed during a period of rounds (independently of
the actual number of transactions they endorsed). Other ways to distribute transaction fees are
also feasible (including the one that is used by bitcoin itself—even though the bitcoin method is
known to be vulnerable to attacks, e.g., the selfing-mining attack).The reward mechanism that we will pair with input endorsers operates as follows. Let C be a
chain consisting of blocks B0 , B1 , . . .. Consider the sequence of blocks that cover the j-th epoch
denoted by B1 , . . . , Bs with timestamps in {jR + 1, . . . , (j + 1)R} that contain an r ≥ 0 sequence
of endorsed inputs that originate from the j-th epoch (some of them may be included as part of
the j + 1 epoch). We define the reward pool Pall to be equal to the sum of the transaction fees
that are included in the endorsed inputs that correspond to the j-th epoch. If a transaction occurs
multiple times (as part of different endorsed inputs) or even in conflicting versions, only the first
occurrence of the transaction is taken into account (and is considered to be part of the ledger at
that position) in the calculation of Pall , where the total order used is induced by the order the
endorsed inputs that are included in C. In the sequence of these blocks, we identify by L1 , . . . , LR
the slot leaders corresponding to the slots of the epoch and by E1 , . . . , Er the input endorsers that
actively contributed the sequence of r endorsed inputs. Subsequently, the i-th stakeholder Ui can
claim a reward up to the amount
where β ∈ [0, 1] is a parameter of the protocol. Claiming a reward is performed by issuing a
“coinbase” type of transaction at any point after 2(k + `) slots in a subsequent epoch to the one
that a reward is being claimed from.
Observe that the above reward mechanism has the following features: (i.) it rewards elected
committee members for just being committee members, independently of whether they issued a
block or not; (ii.) it rewards the input endorsers with the inputs that they have contributed; (iii.)
it rewards entities for epoch j after slot jR + 2(k + `).
We proceed to show that our system is a δ-Nash (approximate) equilibrium, cf. [35, Section
2.6.6]. Specifically, the theorem states that any coalition deviating from the protocol can add at
most an additive δ to its total rewards.
A technical difficulty in the above formulation is that the number of players, their relative stake,
as well as the rewards they receive are based on the transactions that are generated in the course of
the protocol execution itself. To simplify the analysis we will consider a setting where the number
of players is static, the stake they possess does not shift over time and the protocol has negligible
cost to be executed. 
We will establish the fact that our protocol is a δ-Nash equilibrium by proving that the coalition
V , even deviating from the proper protocol behavior, it cannot obtain utility that exceeds RV (E)+δ
for some suitable constant δ > 0.
Theorem 8.1. Fix any δ > 0 and polynomially related parameters k, `, λ; under the same conditions and restrictions as in Theorem 5.5, the honest strategy in the protocol is a δ-Nash equilibrium
against any coalition of players represented as an adversary A, provided that the maximum total
rewards Pall provided in all possible protocol executions is bounded by a polynomial in λ.
Proof. Consider a coalition of rational players V —restricted as in the statement of the theorem—
that engages in a protocol execution together with a number of other players that follow the protocol
faithfully for a total number of L epochs. We will show that any deviation from the protocol will
not result in substantially higher rewards for V . Observe that based on Theorem 5.5, no matter
the strategy of V , with probability 1 − ε for some function ε negligible in the security parameters
k, `, λ the protocol will enable all users to obtain the rewards they are entitled to as slot leaders and
input endorsers. The latter stems from the following. First, from liveness, at least one honest block
will be included every ` slots and hence, in each epoch, all input endorsers that follow the protocol
will have the opportunity to enter their endorsed inputs as many times they were elected to be.
Second, the rewards received will be proportional to the times each party is an input endorser and
issued a block successfully as well as equal to the number of times it is a slot leader. As a result,
except with error ε, the utility received by coalition V is equal to RV . It follows that player V has
expected utility at most E[RV ] + εPAll , where PAll is the maximum amount of rewards produced
in any possible execution. The result follows by the assumption in the statement of the theorem
since εPAll ≤ δ for sufficiently large λ.
Remark 3. In the above theorem, for simplicity, we assumed that protocol costs are not affecting
the final utility (in essence this means that protocol costs are assumed to be negligible). Nevertheless,
it is straightforward to extend the proof to cover a setting where a negative term is introduced in
the payoff function for each player proportional to the number of times inputs are endorsed and the
number of messages transmitted for the beacon protocol. The proof would be resilient to these modifications because endorsed inputs and beacon protocol messages cannot be stifled by the adversary
and hence the reward function can be designed with suitable weights for such actions that offsets
their cost. Still note that the rewards provided are assumed to be “flat” for both slots and endorsed
inputs and thus the costs would also have to be flat. We leave for future work the investigation of
a more refined setting where costs and rewards are proportional to the actual computational steps
needed to verify transactions and issue blocks.
Remark 4. The reward function described, only considers the number of times an entity was an
input endorser without considering the amount of work that was put to verify the given transactions.
Furthermore it is not sensitive to whether a slot leader issued a block or not in its assigned time slot.
We next provide some context behind these choices. First suppose that slot leaders do not receive
a reward when they do not issue a block. It is easy to see that when all parties follow the protocol
the parties will receive the proportion from the reward pool that is associated to block issuance
roughly proportional to their stake. Nevertheless, a malicious coalition can easily increase the ratio
of these rewards by performing a block witholding attack (in this case this would amount to a selfish
mining attack). Given that this happens with non-negligible probability a straightforward definition
of RV (E) that respects this assignment is vulnerable to attack and hence a δ-Nash equilibrium
theorem cannot be shown. Next, we consider the case of extending the reward function so that input
endorsers that are rewarded based on the transactions they verify (as opposed to the flat rewardwe considered in the above theorem). Special care is necessary to design this function. Indeed the
straightforward way to implement it, which is if the first input endorser to verify a transaction that
is part of the pool can make a higher claim for its fee, then there is a strategy for an adversary
to deviate from the protocol and improve its ratio of rewards: perform block withholding and/or
endorsed input censorship to remove endorsed inputs from the blockchain that originate to honest
parties. Then include the removed transactions in an endorsed input that will be transmitted in the
last possible opportunity. As before, given the attack, the natural way to define RV (E) is susceptible
to it and hence a δ-Nash equilibrium theorem cannot be shown. A possible direction for ameliorating
this problem is to share the transaction fee of a transaction between all the input endorsers that
endorsed it. This suggests the following modification to the protocol: whenever you are an input
endorser you should attempt to include all transactions that you have collected for a sequence of k
slots and retransmit your endorsed input in case it is removed from the main chain. We leave the
analysis of such class of reward mechanisms for future work.
As discussed in the previous section, stakeholders must be online in order to generate blocks when
they are selected as slot leaders. However, this might be unattractive to stakeholders with a small
stake in the system. Moreover, requiring that a majority of elected stakeholders participate in the
coin tossing protocol for refreshing randomness introduces a strain on the on the stakeholders and
the network, since it might require broadcasting and storing a large number of commitments and
shares.
We mitigate these issues by providing a method for reducing the size of the group of stakeholders that engage in the coin tossing protocol. Instead of the elected stakeholders directly forming
the committee that will run coin tossing, a group of delegates will act on their behalf. In more
detail, we put forth a delegation scheme, whereby stakeholders will authorize other entities, called
delegates, who may be stakeholders themselves, to represent them in the coin tossing protocol. A
delegate may participate in the protocol only if it represents a certain number of stakeholders whose
aggregate stake exceeds a given threshold. Such a participation threshold ensures that a “fragmentation” attack, that aims to increase the delegate population in order to hurt the performance of
the protocol, cannot incur a large penalty as it is capable to force the size of the committee that
runs the protocol to be small (it is worth noting that the delegation mechanism is similar to mining
pools in proof-of-work blockchain protocols).
To appreciate the benefits of delegation, recall that in the basic protocol (πDPoS ) a committee
member selected by weighing by stake is honest with probability 1/2 +  (this being the fraction
of the stake held by honest players). Thus, the number of honest players selected by k invocations
of weighing by stake is a binomial distribution. We are interested in the probability of a malicious
majority, which can be directly controlled by a Chernoff bound. 
The concept of delegation is simple: any stakeholder can allow a delegate to generate blocks on her
behalf. In the context of our protocol, where a slot leader signs the block it generates for a certain
slot, such a scheme can be implemented in a straightforward way based on proxy signatures [12].
A stakeholder can transfer the right to generate blocks by creating a proxy signing key that
allows the delegate to sign messages of the form (st, d, slj ) (i.e., the format of messages signed in
Protocol πDPoS to authenticate a block). In order to limit the delegate’s block generation power
to a certain range of epochs/slots, the stakeholder can limit the proxy signing key’s valid message
space to strings ending with a slot number slj within a specific range of values. The delegate
can use a proxy signing key from a given stakeholder to simply run Protocol πDPoS on her behalf,
signing the blocks this stakeholder was elected to generate with the proxy signing key. This simple
scheme is secure due to the Verifiability and Prevention of Misuse properties of proxy signature
schemes, which ensure that any stakeholder can verify that a proxy signing key was actually issued
by a specific stakeholder to a specific delegate and that the delegate can only use these keys to
sign messages inside the key’s valid message space, respectively. We remark that while proxy
signatures can be described as a high level generic primitive, it is easy to construct such schemes
from standard digital signature schemes through delegation-by-proxy as shown in [12]. In this
construction, a stakeholder signs a certificate specifying the delegates identity (e.g., its public key)
and the valid message space. Later on, the delegate can sign messages within the valid message
space by providing signatures for these messages under its own public key along with the signed
certificate. As an added advantage, proxy signature schemes can also be built from aggregate
signatures in such a way that signatures generated under a proxy signing key have essentially the
same size as regular signatures [12].
An important consideration in the above setting is the fact that a stakeholder may want to
withdraw her support to a stakeholder prior to its proxy signing key expiration. Observe that proxy
signing keys can be uniquely identified and thus they may be revoked by a certificate revocation
list within the blockchain.
Delegation as described above can ameliorate fragmentation that may occur in the stake distribution. Nevertheless, this does not prevent a malicious stakeholder from dividing its stake to multiple
accounts and, by refraining from delegation, induce a very large committee size. To address this,
as mentioned above, a threshold T , say 1%, may be applied. This means that any delegate representing less a fraction less than T of the total stake is automatically barred from being a committee
member. This can be facilitated by redistributing the voting rights of delegates representing less
than T to other delegates in a deterministic fashion (e.g., starting from those with the highest stakeand breaking ties according to lexicographic order). Suppose that a committee has been formed,
C1 , . . . , Cm , from a total of k draws of weighing by stake.
We next discuss a number of practical attacks and indicate how they are reflected by our modeling
and mitigated.
In a double spending attack, the adversary wishes to revert a transaction that is confirmed by the network. The objective of the attack is to issue a transaction, e.g., a payment from an adversarial account holder to a victim recipient, have the transaction confirmed
and then revert the transaction by, e.g., including in the ledger a second conflicting transaction.
Such an attack is not feasible under the conditions of Theorem 5.5. Indeed, persistence ensures
that once the transaction is confirmed by an honest player, all other honest players from that point
on will never disagree regarding this transaction. Thus it will be impossible to bring the system to
a state where the confirmed transaction is invalidated (assuming all preconditions of the theorem
hold). See the next section for an experimental discussion about double spending.
Grinding attacks In stake grinding attacks, the adversary tries to influence the slot leader
selection process to improve its chances of being selected to generate blocks (which can be used to
perform other attacks such as double spending). Basically, when generating a block that is taken
as input by the slot leader selection process, the adversary first tests several possible block headers
and block contents in order to find the one that gives it the best chance of being selected as a
slot leader again in the future. While this attack affects PoS based cryptocurrencies that collect
randomness for the slot leader selection process from raw data in the blockchain itself (i.e. from
block headers and contents), our protocol uses a coin tossing protocol that is proven to generate
unbiased uniform randomness as discussed in Section 5.2. We show that an adversary cannot
influence the randomness generated in Figure 12, which is guaranteed to be uniformly random,
thus guaranteeing that slot leaders are selected with probability proportional to their stake.
Transaction denial (censorship) attacks In a transaction denial attack, the adversary wishes
to prevent a certain transaction from becoming confirmed. For instance, the adversary may want
to target a specific account and prevent the account holder from issuing an outgoing transaction.
Such an attack is not feasible under the conditions of Theorem 5.5. Indeed, liveness ensures that,
provided the transaction is attempted to be inserted for a sufficient number of slots by the network,
it will be eventually confirmed.
Desynchronization attacks In a desynchronization attack, a shareholder behaves honestly but
is nevertheless incapable of synchronizing correctly with the rest of the network. This leads to
ill-timed issuing of blocks and being offline during periods when the shareholder is supposed to
participate. Such an attack can be mounted by preventing the party’s access to a time server or
any other mechanism that allows synchronization between parties. Moreover, a desynchronization
may also occur due to exceedingly long delays in message delivery. Our model allows parties to
become desynchronized by incorporating them into the adversary. No guarantees of liveness andpersistence are provided for desynchronized parties and thus we can get security as long as parties
with less than 50% of stake get desynchronized. If more than 50% parties get desynchronized our
protocol can fail. More general models like partial synchrony [23, 39] are interesting to consider
in the PoS design setting. See the follow up work, Ouroboros Praos, for more information on this
topic [22].
Eclipse attacks In an eclipse attack, message delivery to a shareholder is violated due to a
subversion in the peer-to-peer message delivery mechanism. As in the case of desynchronization
attacks, our model allows parties to be eclipse attacked by incorporating them into the adversary.
No guarantees of liveness or persistence are provided for such parties.
51% attacks A 51% attack occurs whenever the adversary controls more than the majority of
the stake in the system. It is easy to see that any sequence of slots in such a case is with very high
probability forkable and thus once the system finds itself in such setting the honest stakeholders
may be placed in different forks for long periods of time. Both persistence and liveness can be
violated.
Bribery Attacks In bribery attacks [13], an adversary deliberately pays miners (through cryptocurrency or fiat money) to work on specific blocks and forks, aiming at generating an arbitrary
fork that benefits the adversary (e.g. by supporting a double spending attack). Miners of PoW
based cryptocurrencies do not have to own any stake in order to mine blocks, which makes this
attack strategy feasible. In this setting, if the adversary offers a bribe higher than the reward
for correctly generating a block, any rational miner has a clear incentive to accept the bribe and
participate in the attack since it increases the miner’s financial outcome. However, in our PoS
based protocol, malicious slot leaders who agree to deliberately attack the system not only risk to
forego any potential profit they would earn from behaving honestly but may also risk to lose equity.
Notice that slot leaders must have money invested in the system in order to be able to generate
blocks and if an attack against the system is observed this might bring currency value down. Even
if the bribe is higher than the reward for correct behavior, the loss from currency devaluation can
easily offset any additional profits made by participating in this attack. Hence, bribery attacks may
be be less effective against a PoS based consensus protocol than a PoW based one. Currently our
rationality model does not formally encompass this attack strategy and investigating its efficacy
against PoS based consensus protocols is left as a future work.
Long-range attacks An attacker who wishes to double spend at a later point in time can mount
a long-range attack [14] by computing a longer valid chain that starts right after the genesis block
where it is the single stakeholder actively participating in the protocol. Even if this attacker
owns a small fraction of the total stake, it can locally compute this chain generating only the
blocks for slots where it is elected the slot leader and keep generating blocks ahead of current
time until its alternative chain has more blocks than the main chain. Now, the attacker can post
a transaction to the main chain, wait for it to be confirmed (and for goods to be delivered in
exchange for the transaction) and present the longer alternative chain to invalidate its previously
confirmed transaction. This attack is ineffective against Ouroboros for two reasons: Protocol πDLS
will only output valid leader selection data allowing for the protocol to continue if a majority of
the stakeholders participate (or have delegates participate on their behalf) and stakeholders will
reject blocks generated for slots that are far ahead of time. Since the alternative chain is generated
artificially with blocks and protocol messages generated solely by an attacker who controls a smallfraction of the stake, the leader selection data needed to start new epochs will be considered invalid
by other nodes. Even if the attacker could find a strategy to generate an alternative chain with
valid leader selection data, presenting this chain and its blocks generated at slots that are far ahead
of time would not result in a successful attack since those blocks far ahead of time would be rejected
by the honest stakeholders and the final alternative chain would be shorter than the main chain.
Nothing at stake attacks The “nothing at stake” problem refers in general to attacks against
PoS blockchain systems that are facilitated by shareholders continuing simultaneously multiple
blockchains exploiting the fact that little computational effort is needed to build a PoS blockchain.
Provided that stakeholders are frequently online, nothing at stake is taken care of by our analysis
of forkable strings (even if the adversary brute-forces all possible strategies to fork the evolving
blockchain in the near future, there is none that is viable), and our chain selection rule that
instructs players to ignore very deep forks that deviate from the block they received the last time
they were online. It is also worth noting that, contrary to PoW-based blockchains, in our protocol
it is infeasible to have a fork generated in earnest by two shareholders. This is because slots are
uniquely assigned and thus at any given moment there is a single uniquely identified shareholder
that is elected to advance the blockchain. Players following the longest chain rule will adopt the
newly minted block (unless the adversary presents at that moment an alternative blockchain using
older blocks). It is remarked in [15] that the “tragedy of commons” might lead stakeholders in
some PoS based schemes to adhere to attacks because they do not have the power to deter attacks
by themselves and would incur financial losses even if they did not join the attack. This would
lead rational stakeholders to accept small bribes in alternative currencies that might at least obtain
some financial gain. However, in the incentive structure of Ouroboros, slot leaders and endorsers
who could potentially join an attack would receive rewards in both the main and the adversarial
chain, resulting in those stakeholders not achieving higher profits by joining the attack.
Past majority attacks As stake moves our assumption is that only the current majority of
stakeholders is honest. This means that past account keys (which potentially do not hold any stake
at present) may be compromised. This leads to a potential vulnerability for any PoS system since a
set of malicious shareholders from the past can build an alternative blockchain exploiting such old
accounts and the fact that it is effortless to build such a blockchain. In light of Theorem 5.5 such
attack can only occur against shareholders who are not frequently online to observe the evolution
of the system or in case the stake shifts are higher than what is anticipated by the preconditions
of the theorem. This can be seen a special instance of the nothing at stake problem, where the
attacker no longer owns any stake in the system and is thus free from any financial losses when
conducting the attack.
Selfish-mining In this type of attack, an attacker withholds blocks and releases them strategically attempting to drop honestly generated blocks from the main chain. In this way the attacker
reduces chain growth and increases the relative ratio of adversarially generated blocks. In conventional reward schemes, as that of bitcoin, this has serious implications as it enables the attacker
to obtain a higher rate of rewards compared to the rewards it would be receiving in case it was
following the honest strategy. Using our reward mechanism however, selfish mining attacks are
neutralized. The intuition behind this, is that input endorsers, who are the entities that receive
rewards proportionally to their contributions, cannot be stifled because of block withholding: any
input endorser can have its contribution accepted for a sufficiently long period of time after its
endorsement took place, thus ensuring it will be incorporated into the blockchain (due to sufficientchain quality and chain growth). Given that input endorsers’ contributions are (approximately)
proportional to their stake this ensures that reward distribution cannot be affected substantially
by block withholding.
We have implemented a prototype instantiation of Ouroboros in Haskell as well as in the Rustbased Parity Ethereum client in order to evaluate its concrete performance. More specifically, we
have implemented Protocol πDPoS using Protocol πDLS to generate leader selection parameters (i.e.,
generating fresh randomness for the weighed stake sampling procedure). For this instantiation, we
use the PVSS scheme of [44] implemented over the elliptic curve secp256r1. This PVSS scheme’s
share verification information includes a commitment to the secret, which is also used as the
commitment specified in protocol πDLS ; this eliminates the need for a separate commitment to
be generated and stored in the blockchain. In order to obtain better efficiency, the final output ρ
of Protocol πDLS is a uniformly random binary string of 32 bytes. This string is then used as a
seed for a PRG (ChaCha in our implementation, [10]) and stretched into R random labels of log τ
bits corresponding to each slot in an epoch. The weighing by stake leader selection process is then
implemented by using the random binary string associated to each epoch to perform the sequence
of coin-flips for selecting a stakeholder. The signature scheme used for signing blocks is ECDSA,
also implemented over curve secp256r1.
We first examine the time required for confirming a transaction in a setting where the network is
not under substantial load and transactions are processed as they appear.

In Figure 14 we lay out a comparison in terms of transaction confirmation time between Bitcoin
and Ouroboros showing how much a verifier has to wait to be sure that the best possible8 doublespending attack succeeds with probability less than 0.1%. In the case of Bitcoin, we consider a
double-spending attacker that commands a certain percentage of total hashing power and wishes
to revert a transaction. The attacker attempts to double-spend via a block-witholding attack as
described in the same paper (the attacker mines a private fork and releases it when it is long
The “best possible” is only in the the case of Ouroboros, for Bitcoin we use the best known attack.
In the case of Ouroboros we consider a double spending attacker that attempts to brute
force the space of all possible forks for the current slot leader distribution in a certain segment of
the protocol and commands a certain percentage of the total stake. We consider both the covert
and the general adversarial setting for Ouroboros.
In all of the scenarios, we measure the number of minutes that one has to wait in order to achieve
probability of double spending less than 0.1%. In Fig. 15 we present a graph that illustrates the
speedup graphically.
Figure 15: Ouroboros vs. Bitcoin speedup of transaction confirmation time against a hypothetical
double spending attacker for assurance level 99.9%. Ouroboros is at least 10 to 5 times faster for
regular adversaries and 16 to 10 times faster for covert adversaries.
We note that the above measurements compare our Ouroboros implementation with Bitcoin
in the way the two systems are parameterized (with 10 minute block production rate for Bitcoin
and 20 second slots for Ouroboros, a conservative parameter selection). Exploring alternative
parameterizations for Bitcoin (such as making the proof-of-work easier) can speed up the transaction
processing, nevertheless this cannot be done without carefully measuring the impact on overall
security.
We implemented Ouroboros as an instance of the Rust-based Ethereum Parity client.9 Subsequently, experiments were run using Amazon’s Elastic Compute Cloud (EC2) ‘c4.2xlarge‘ instances
in the ‘us-east-1‘ region with a smaller “runner” instance responsible for coordinating each of the
“worker” instances.
Each experiment consists of several steps:
Each worker instance is started in an “isolated” mode where none of the nodes talk to each
other. During this period, a Parity account is recovered on each node and a start time for
the network is established.
Each worker instance is restarted in a production mode that allows communication between
the nodes and transactions to be mined.
A single worker instance is informed about all the other nodes. All nodes become aware of
all other nodes via Parity’s peer-to-peer discovery methods.
Each worker instance has a number of transactions generated and ingested.
In each experiment, 650,000 total transactions are generated between the participating nodes
who shared stake equally. The amount transferred in any given transaction is small enough to
avoid any account running out of funds. Each instance generates all the transactions using a hardcoded shared random seed, then keeps the transactions originating from the local user account. 20
transactions are saved in a single JSON file, ready to be directly passed to the Parity RPC endpoint
using the ‘curl‘ command line tool. During ingestion, a single file of 20 transactions is ingested
and one second is spent idle between each file to avoid overwhelming the instances with too many
requests.
Various setups were tested, focusing on adjusting the Ouroboros slot duration and the number
of participating nodes. 10, 20, 30, and 40 nodes were tested, ultimately limited by the number of
instances allowed in a single EC2 region. Slot durations of 5, 10, and 20 seconds were also tested.
Variance between experiments was small. In Figure 16 we present the case of 40 nodes and slot
length of 5 seconds that exhibits a median value of 257.6 transaction per second.
The analysis in the paper demonstrates that if w ∈ {0, 1}n is forkable, then there is in fact a flat
fork F ` w with the extra property that F has no more than two “components,” which is to say
that there are two non-empty tines p and q with the property that for any non-empty tine r of F ,
either r ∼ p or r ∼ q. It is natural to ask whether “two tines suffice,” which is to say that there is
always a flat fork F ` w which is the union of two tines.
In fact, there are forkable strings which require three tines to fork. Specifically, consider the
string
w = 02k 1k (1001)1k 02k .
The flat fork shown in Figure 17 below proves that w is forkable. However, no two tines can
successfully fork w.