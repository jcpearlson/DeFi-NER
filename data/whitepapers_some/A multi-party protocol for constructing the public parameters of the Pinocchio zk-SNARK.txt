
Recent efficient constructions of zero-knowledge Succinct Non-interactive Arguments of Knowledge (zk-SNARKs), require a setup phase in which a common-reference string (CRS) with a
certain structure is generated. This CRS is sometimes referred to as the public parameters of
the system, and is used for constructing and verifying proofs. A drawback of these constructions
is that whomever runs the setup phase subsequently possesses trapdoor information enabling
them to produce fraudulent pseudoproofs.
Building on a work of Ben-Sasson, Chiesa, Green, Tromer and Virza [BCG+ 15], we construct
a multi-party protocol for generating the CRS of the Pinocchio zk-SNARK [PHGR16], such that
as long as at least one participating party is not malicious, no party can later construct fraudulent
proofs except with negligible probability. The protocol also provides a strong zero-knowledge
guarantee even in the case that all participants are malicious.
This method has been used in practice to generate the required CRS for the Zcash cryptocurrency blockchain.

The recently deployed Zcash cryptocurrency supports shielded (private) transactions where sender,
receiver and amount are not revealed; and yet, an outside observer can still distinguish between a
valid and non-valid transaction. The “cryptographic engine” that enables these shielded transactions is a zero-knowledge Succinct Non-interactive Argument of Knowledge (zk-SNARK); currently,
Zcash uses the Pinocchio zk-SNARK [PHGR16], or more precisely, the variant of it described in
[BCTV14] as implemented in libsnark[lib].
A potential weakness of Zcash, is that if anybody obtained the trapdoor information corresponding to the Common Reference String (CRS) used for constructing and verifying the SNARKs, they
could forge unlimited amounts of the currency, potentially without anyone detecting they are doing
so.
Motivated by this, Zcash generated the required CRS in an elaborate “ceremony” [Wil] to
reduce the chance of this happening. The purpose of this technical report is to give a detailed
description of the multi-party protocol that was used in the ceremony.
Our results Ben-Sasson, Chiesa, Green, Tromer and Virza [BCG+ 15] presented a generic method
for computing CRSs of zk-SNARKs in a multi-party protocol, with the property that only if all
players collude together they can reconstruct the trapdoor, or, more generally, deduce any other
useful information beyond the resultant CRS.Based on [BCG+ 15], we devise an arguably simpler method for generating the CRS of the
Pinocchio zk-SNARK [PHGR16] with a similar security guarantee: Namely, given that the CRS
generated by the protocol is later used to verify proofs; a party controlling all but one of the players
will not be able to construct fraudulent proofs except with negligible probability. See Theorem 4.8
for details.
Moreover, we show that even if a malicious party controls all players, statistical zero-knowledge
holds when constructing proofs according to the resultant parameters. Interestingly, this means the
protocol is useful also when run by one player ; as the transcript will provide proof to the prover
that sending her proof will not leak additional information.1
This property has been recently called subversion Zero-Knowledge [BFS16]. As opposed to the
soundness guarantee, zero-knowledge only requires the random oracle model; and in particular, no
knowledge assumptions in contrast to some recent works on subversion-ZK [Fuc17, ABLZ17]. On
the other hand, our proof only obtains statistical-ZK with polynomially small error as opposed to
the mentioned recent works that can obtain negligible error (again, using knowledge assumptions).
See Theorem 4.10 for details.
Organization of paper Section 2 introduces some terminology and auxiliary methods that will
be used in the protocol. Section 3 describes the protocol in detail. Section 4 describes the security
proof of the protocol.

We assume we have at our disposal a function COMMIT taking as input strings of arbitrary
length; that, intuitively speaking, behaves like a commitment scheme. That is, it is infeasible to
deduce COMMIT’s input from seeing its output, and it is infeasible to find two inputs that COMMIT
maps to the same output. In our implementation we use the BLAKE-2 hash function as COMMIT.
For the actual security proof, we need to assume that COMMIT’s outputs are chosen by a random
oracle.

Symmetric definitions In the following sections we introduce several methods that receive as
parameters elements of both G1 and G2 . We assume implicitly that whenever such a definition is
made, we also have the symmetric definition where the roles are reversed between what parameters
come from G1 and G2 . For example, if we define a method receiving as input a vector of G1
elements and a pair of G2 elements. We assume thereafter that we also have the symmetric method
receiving as input a vector of G2 elements and a pair of G1 elements.



The random-coefficient subprotocol

A large part of the protocol will consist of invocations of the random-coefficient subprotocol.

Protocol description

The participants The protocol is conducted by n players, a coordinator, and a protocol verifier.
In the implementation the role of the coordinator and protocol verifier can be played by the same
server. We find it useful to separate these roles, though, as the actions of the protocol verifier may
be executed only after the protocol has terminated, if one wishes to reduce the time the players have
to be engaged. Moreover, any party wishing to check the validity of the transcript and generated
parameters can do so solely with access to the protocol transcript. On the other hand, this has the
disadvantage that non-valid messages will be detected only in hindsight, and the whole process will
have to be restarted if one wishes to generate valid SNARK parameters.
Similarly, the role of the coordinator is not strictly necessary if one assumes a blackboard model
where each player sees all messages broadcasted. (In our actual implementation the coordinator
passes messages between the players). Our security analysis holds when all messages are seen by all
players. However, even in such a blackboard model there is an advantage of having of a coordinator
role: At the beginning of Round 3 a heavy computation needs to performed (Subsection 3.3)
that in theory could be performed by the first player before he sends his message for that round.
However, as this heavy computation does not require access to any secrets of the players, having
the coordinator perform it can save much time, if the coordinator is run on a strong server, and
the players have weaker machines.
The protocol consists of four “round-robin” rounds, where for each i ∈ [n], player Pi can send his
message after receiving the message of Pi−1 . P1 can send his message after receiving an “initializer
message” from the coordinator, which is empty in some of the rounds. An exception of this is
the first round, where all players may send their message to the coordinator in parallel. However,
security is not harmed if a player sees other players’ messages before sending his in that round.
Round 2 is divided into several parts for clarity, however the messages of a player Pi in all parts
of that round can be sent in parallel. Similarly, Round 3 and 4 consist of several one round roundrobin subprotocols; however, the messages of a player Pi in all these subprotocols can be sent in
parallel.

In the actual code a more complex set of elements is used that can be efficiently derived from elementsi , as
described in Appendix A. The reason we use the more complex set is that it potentially provides more security as it
contains less information about secretsi . However, the proof works as well with this definition of ei and it provides a
significantly simpler presentation. We explain in Appendix A the slight modification for protocol and proof for using
the more complex element set.
To avoid a quadratic proving time the polynomials in the QAP must be evaluated in a Lagrange
basis. There seems to be no way of directly computing a Lagrange basis at τ in a 1-round MPC
in a similar way we did for the standard basis in the Random-Powers subprotocol. Thus we will
do ‘FFT in the coefficient’ to compute the Lagrange basis on the output of the random-powers
subprotocol. Details and definitions follow. 
We use bilinear versions of the Strong Diffie-Helman, Power Diffie-Helman, and Knowledge of
Exponent assumption as in [CFH+ 15]. It will be convenient to denote G∗ := G1 \ {0} × G2 \ {0},
and as before by g = (g1 , g2 ) a pair of generators for both groups.
 the probability that A outputs e(g1 , g2 ) τ +c , for some c ∈ F∗r is negl(log r).


We refer to Appendix B of [BCTV14] for a description of the Pinocchio protocol [PHGR16] with
notation close to what is used here. We also give a semi-formal description of the protocol in
Appendix B.
Furthermore, one may refer to [PHGR16] and [BCTV14] for definitions relating to quadratic
arithmetic programs (QAPs), that we assume familiarity with here. Given a QAP instance φ of
degree d, we typically denote by paramsφ a legitimate set of Pinocchio parameters, i.e., proving
key and verification key, for φ. 

Campanelli, Gennaro, Goldfeder and Nizzardo [CGGN17] have recently noted that a malicious
choice of paramsφ can potentially break the zero-knowledge guarantee of the Pinocchio protocol. We
prove that statistical zero-knowledge holds when using the parameters generated by our protocol,
even in the case that all n players are malicious and colluding, provided the prover verifies the
protocol transcript before sending her proof.
Denote by P the (honest) prover of the Pinocchio protocol. We can think of P as a randomized
function P(φ, x, paramsφ , ω) generating a proof according to the instance, input, public parameters
and witness. (See Appendix B of [BCTV14] for a full description of P.) We slightly alter P and
think of it as an algorithm P(φ, x, transcript, ω) that also receives a protocol transcript transcript,
and first applies the protocol verifier on transcript. If the protocol verifier rejects, P outputs rej and
nothing else. If the protocol verifier accepts, P derives the parameters paramsφ from the transcript,
and outputs P(φ, x, paramsφ , ω) for the original prover P. We will assume further for simplicity that
P applies a deterministic protocol verifier. This mean she will not use the more efficient randomized
checking of whether a vector is an s-vector as described in Claim 2.3, but will check each s-pair
separately as described in Claim 2.2.
Theorem 4.10. [Statistical Zero-Knowledge] For any polynomial P and positive integer8 n, there
is an efficient sim such that the following holds. Fix any efficient B controlling all n players in
the protocol, instance φ, input x and witness ω. Let D be the distribution obtained by outputting
the protocol transcript transcript(B) concatenated with the proof P(φ, x, transcript(B), ω) (over the
randomness of B in the protocol, the randomness of the oracle R, and that of P in generating the
proof ). Then the distribution Dsim of the output of simB has distance at most 1/P (log r) to D.
Proof. Note that if we can simulate D with error 1/P (log r) conditioned on every fixing of the
randomness of B, we can simulate the fully randomized B with the same error. So the simulator
begins by choosing the randomness of B uniformly, and we can assume we are working with a
deterministic B. Assume B always makes exactly Q queries to the random oracle R emulating
COMMIT (if this is just an upper bound we can think of B not reading the last answers sometimes).
As before, we denote by M the range size of R and assume r ≤ M ≤ poly(r). The transcript outputtranscript(B) is a deterministic function of a sequence r of answers of R to queries of B. We denote
this transcript transcript(r). The corresponding set of queries {q1 , . . . , qQ } of B to R is also a
deterministic function of r. More specifically, the first i + 1 queries are a deterministic function of
the first i elements of r. 