TRON is an ambitious project dedicated to the establishment of a truly decentralized Internet and its
infrastructure. The TRON Protocol, one of the largest blockchain-based operating systems in the
world, offers public blockchain support of high throughput, high scalability, and high availability for
all Decentralized Applications (DApps) in the TRON ecosystem. The July 2018 acquisition of
BitTorrent further cemented TRON’s leadership in pursuing a decentralized ecosystem.

The introduction of Bitcoin in 2009 revolutionized society’s perception of the traditional financial
system in the wake of the Great Recession (2007-2008). As centralized hedge funds and banks
collapsed from speculation in opaque financial derivatives, blockchain technology provided a
transparent universal ledger from which anybody could glean transaction information. The
transactions were cryptographically secured using a Proof of Work (PoW) consensus mechanism,
thus preventing double spend issues.
In late 2013, the Ethereum white paper proposed a network in which smart contracts and a
Turing-complete Ethereum Virtual Machine (EVM) would allow developers to interact with the
network through DApps. However, as transaction volumes in Bitcoin and Ethereum peaked in 2017,
it was apparent from the low transaction throughput times and high transaction fees that
cryptocurrencies like Bitcoin and Ethereum in their existing state were not scalable for widespread
adoption. Thus, TRON was founded and envisioned as an innovative solution to these pressing
scalability challenges.

The TRON DAO was established in July 2017 in Singapore. In December 2017, TRON had
launched its open source protocol. The Testnet, Blockchain Explorer, and Web Wallet were all
launched by March 2018. TRON Mainnet launched shortly afterward in May 2018, marking the
Odyssey 2.0 release as a technical milestone. In June 2018, TRON declared its independence
with the creation of the Genesis block, along with the July 2018 acquisition of BitTorrent. In
October 2018, TRON launched the TRON Virtual Machine (TVM), a complete developers’ toolset,
and 360 support system. The TRON roadmap involves combining BitTorrent’s 100 million users
with the TRON network via Project Atlas, as well as fostering the developer community to launch
exciting new DApps on the TRON network.
An address or wallet consisting of account credentials on the TRON network are generated by a
key pair, which consists of a private key and a public key, the latter being derived from the former
through an algorithm. The public key is usually used for session key encryption, signature
verification, and encrypting data that could be decrypted by a corresponding private key.
An application binary interface (ABI) is an interface between two binary program modules; usually
one of these modules is a library or an operating system facility, and the other is a user run
program.
An application programming interface (API) is mainly used for user clients development. With API
support, token issuance platforms can also be designed by developers themselves.
In TRON's documents, asset is the same as token, which is also denoted as TRC-10 token.
Bandwidth Points (BP)
To keep the network operating smoothly, TRON network transactions use BP as fuel. Each account
gets 5000 free daily BP and more can be obtained by freezing TRX for BP. Both TRX and TRC-10
token transfers are normal transactions costing BP. Smart contract deployment and execution
transactions consume both BP and Energy.
Blocks contain the digital records of transactions. A complete block consists of the magic number,
block size, block header, transaction counter, and transaction data.
Block production rewards are sent to a sub-account (address/wallet). Super Representatives can
claim their rewards on Tronscan or through the API directly.
A block header is part of a block. TRON block headers contain the previous block’s hash, the
Merkle root, timestamp, version, and witness address.
Cold wallet, also known as offline wallet, keeps the private key completely disconnected from any
network. Cold wallets are usually installed on "cold" devices (e.g. computers or mobile phones
staying offline) to ensure the security of TRX private key.
Decentralized Application is an App that operates without a centrally trusted party. An application
that enables direct interaction/agreements/communication between end users and/or resources
without a middleman.
gRPC2 (gRPC Remote Procedure Calls) is an open source remote procedure call (RPC) system
initially developed at Google. It uses HTTP/2 for transport, Protocol Buffers as the interface
description language, and provides features such as authentication, bidirectional streaming and flow
control, blocking or nonblocking bindings, and cancellation and timeouts. It generates
cross-platform client and server bindings for many languages. Most common usage scenarios
include connecting services in microservices style architecture and connecting mobile devices, and
browser clients to backend services.
Hot wallet, also known as online wallet, allows user's private key to be used online, thus it could be
susceptible to potential vulnerabilities or interception by malicious actors.
Java Development Kit is the Java SDK used for Java applications. It is the core of Java
development, comprising the Java application environment (JVM+Java class library) and Java
tools.
TRON has a KhaosDB in the full-node memory that can store all the newly-forked chains generated
within a certain period of time and supports witnesses to switch from their own active chain swiftly
into a new main chain. See 2.2.2 State Storage for more details.
LevelDB was initially adopted with the primary goal to meet the requirements of fast R/W and rapid
development. After launching the Mainnet, TRON upgraded its database to an entirely customized
one catered to its very own needs. See 2.2.1 Blockchain Storage for more details.
A Merkle root is the hash of all hashes of all transactions included as part of a block in a blockchain
network. See 3.1 Delegated Proof of Stake (DPoS) for more details.
A version of the network running in a single-node configuration. Developers can connect and test
features without worrying about the economic loss. Testnet tokens have no value and anyone can
request more from the public faucet.
In distributed computing, a remote procedure call (RPC) is when a computer program causes a
procedure (subroutine) to execute in a different address space (commonly on another computer on
a shared network), which is coded as if it were a normal (local) procedure call, without the
programmer explicitly coding the details for the remote interaction.
Scalability is a feature of the TRON Protocol. It is the capability of a system, network, or process to
handle a growing amount of work or its potential to be enlarged to accommodate that growth.
SUN replaced drop as the smallest unit of TRX. 1 TRX = 1,000,000 SUN.
High throughput is a feature of TRON Mainnet. It is measured in Transactions Per Second (TPS),
namely the maximum transaction capacity in one second.
The approximate time of block production is recorded as Unix timestamp, which is the number of
milliseconds that have elapsed since 00:00:00 01 Jan 1970 UTC.

A standard of crypto token on TRON platform. Certain rules and interfaces are required to follow
when holding an initial coin offering on TRON blockchain.
TRX stands for Tronix, which is the official cryptocurrency of TRON.
TRON adopts a 3-layer architecture divided into Storage Layer, Core Layer, and Application Layer.
The TRON protocol adheres to Google Protobuf, which intrinsically supports multi-language
extension.
There are several modules in the core layer, including smart contracts, account management, and
consensus. A stack-based virtual machine is implemented on TRON and an optimized instruction
set is used. In order to better support DApp developers, Solidity4 was chosen as the smart contract
language, followed by future support of other advanced languages. In addition, TRON's consensus
mechanism is based on Delegated Proof of Stake (DPoS) and many innovations were made in
order to meet its unique requirements.

TRON designed a unique distributed storage protocol consisting of Block Storage and State
Storage. The notion of a graph database was introduced into the design of the storage layer to
better meet the need for diversified data storage in the real world.
TRON blockchain storage chooses to use LevelDB, which is developed by Google and proven
successful with many companies and projects. It has high performance and supports arbitrary byte
arrays as both keys and values, singular get, put and delete, batched put and delete, bi-directional
iterators, and simple compression using the very fast Snappy algorithm.
TRON has a KhaosDB in the full-node memory that can store all the newly forked chains generated
within a certain period of time and supports witnesses to switch from their own active chain swiftly
into a new main chain. It can also protect blockchain storage by making it more stable from being
terminating abnormally in an intermediate state.
Developers can create a diverse range of DApps and customized wallets on TRON. Since TRON
enables smart contracts to be deployed and executed, the opportunities of utility applications are
unlimited.
TRON protocol adheres to Google Protocol Buffers5, which is a language-neutral, platform-neutral,
and extensible way of serializing structured data for use in communications protocols, data storage,
and more.
Protocol Buffers (Protobuf) is a flexible, efficient, automated mechanism for serializing structured
data, similar to JSON or XML, but much smaller, faster and simpler.
Protobuf (.proto) definitions can be used to generate code for C++, Java, C#, Python, Ruby,
Golang, and Objective-C languages through the official code generators. Various third-party
implementations are also available for many other languages. Protobuf eases development for
clients by unifying the API definitions and also optimizing data transfers. Clients can take the API proto from TRON’s protocol repository and integrate through the automatically-generated code
libraries.
As a comparison, Protocol Buffers is 3 to 10 times smaller and 20 to 100 times faster than XML,
with less ambiguous syntax. Protobuf generates data access classes that are easier to use
programmatically.
TRON Protocol provides a RESTful HTTP API alternative to the Protobuf API. They share the same
interface but the HTTP API can be readily used in javascript clients.
The TVM is a lightweight, Turing complete virtual machine developed for TRON’s ecosystem. The
TVM connects seamlessly with the existing development ecosystem to provide millions of global
developers with a custom-built blockchain system that is efficient, convenient, stable, secure, and
scalable.
The TRON network natively supports decentralized exchange functions. A decentralized exchange
consists of multiple trading pairs. A trading pair (notation “Exchange”) is an Exchange Market
between TRC-10 tokens, or between a TRC-10 token and TRX. Any account can create a trading
pair between any tokens, even if the same pair already exists on the TRON network. Trading and
price fluctuations of the trading pairs follow the Bancor Protocol6. The TRON network stipulates that
the weights of the two tokens in all trading pairs are equal, so the ratio of their balances is the price
between them. For example, consider a trading pair containing two tokens, ABC and DEF. ABC has
a balance of 10 million and DEF has a balance of 1 million. Since their weights are equal, 10 ABC =
1 DEF. This means that the ratio of ABC to DEF is 10 ABC per DEF.
The TRON blockchain code is implemented in Java and was originally a fork from EthereumJ.
The earliest consensus mechanism is the Proof of Work (PoW) consensus mechanism. This
protocol is currently implemented in Bitcoin7 and Ethereum8. In PoW systems, transactions
broadcast through the network are grouped together into nascent blocks for miner confirmation. The
confirmation process involves hashing transactions using cryptographic hashing algorithms until a
merkle root has been reached, creating a merkle tree:

8 TRX transactions are hashed into the merkle root. This merkle root is then included in the block header, which
is attached to the previously confirmed blocks to form a blockchain. This allows for easy and transparent tracking of
transactions, timestamps, and other related information.
Cryptographic hashing algorithms are useful in network attack prevention because they possess
several properties.
Input/Output length size​ - The algorithm can pass in an input of any length in size, and
outputs a fixed length hash value.
Efficiency​ - The algorithm is relatively easy and fast to compute.
Preimage resistance​ - For a given output ​z,​ it is impossible to find any input ​x​ such that
h(x) =​ ​z.​ In other words, the hashing algorithm ​h(x)​ is a one-way function in which only the
output can be found, given an input. The reverse is not possible.
 In other words, the probability of finding two different inputs hashing to the same
output is extremely low. This property also implies ​second preimage resistance​.
Second preimage resistance​ - Given ​x​1​, and thus ​h(x​1​),​ it is computationally infeasible to
find any ​x​2​ such that ​h(x​1​) = h(x​2)​ ​. While this property is similar to ​collision resistance,​ the
property differs in that it is saying an attacker with a given ​x1​ ​ will find it computationally
infeasible to find any ​x2​ ​ hashing to the same output.
Deterministic​ - maps each input to one and only one output.
Avalanche effect​ - a small change in the input results in an entirely different output.

These properties give the cryptocurrency network its intrinsic value by ensuring attacks do not
compromise the network. When miners confirm a block, they are rewarded tokens as a built-in
incentive for network participation. However, as the global cryptocurrency market capitalization
steadily increased, the miners became centralized and focused their computing resources on
hoarding tokens as assets, rather than for network participation purposes. CPU miners gave way to
GPUs, which in turn gave way to powerful ASICs. In one notable study, the total power
consumption of Bitcoin mining has been estimated to be as high as 3 GW10, comparable to Ireland’s
power consumption. This same study projected total power consumption to reach 8 GW in the near
future.
To solve the energy waste issue, the Proof of Stake (PoS) consensus mechanism was proposed by
many new networks. In PoS networks, token holders lock their token balances to become block
validators. The validators take turns proposing and voting on the next block. However, the problem
with standard PoS is that validator influence correlates directly to the amount of tokens locked up.
This results in parties hoarding large amounts of the network’s base currency wielding undue
influence in the network ecosystem.
The TRON consensus mechanism uses an innovative Delegated Proof of Stake system in which 27
Super Representatives (SRs) produce blocks for the network. Every 6 hours, TRX account holders
who freeze their accounts can vote for a selection of SR candidates, with the top 27 candidates
deemed the SRs. Voters may choose SRs based on criteria such as projects sponsored by SRs toincrease TRX adoption, and rewards distributed to voters. This allows for a more democratized and
decentralized ecosystem. SRs’ accounts are normal accounts, but their accumulation of votes
allows them to produce blocks. With the low throughput rates of Bitcoin and Ethereum due to their
PoW consensus mechanism and scalability issues, TRON’s DPoS system offers an innovative
mechanism resulting in 2000 TPS compared to Bitcoin’s 3 TPS and Ethereum’s 15 TPS.
The TRON protocol network generates one block every three seconds, with each block awarding 32
TRX to Super Representatives. A total of 336,384,000 TRX will be awarded annually to the 27 SRs.
Each time an SR finishes block production, rewards are sent to a sub-account in the super-ledger.
SRs can check, but not directly make use of these TRX tokens. A withdrawal can be made by each
SR once every 24 hours, transferring the rewards from the sub-account to the specified SR
account.
The three types of nodes on the TRON network are Witness Node, Full Node, and Solidity Node.
Witness nodes are set up by SRs and are mainly responsible for block production and proposal
creation/voting. Full nodes provide APIs and broadcast transactions and blocks. Solidity nodes sync
blocks from other Full Nodes and also provide indexable APIs.
The three types of accounts in the TRON network are regular accounts, token accounts, and
contract accounts.
Regular accounts are used for standard transactions.
Token accounts are used for storing TRC-10 tokens.
Contract accounts are smart contract accounts created by regular accounts and can be
triggered by regular accounts as well.
There are three ways to create a TRON account.
Create a new account through API
Transfer TRX into a new account address
Transfer any TRC-10 token into a new account address
An offline key-pair consisting of an address (public key) and a private key, and not recorded by the
TRON network, can also be generated. The user address generation algorithm consists of
generating a key-pair and then extracting the public key (64-byte byte array representing x, y
coordinates). Hash the public key using the SHA3-256 function (the SHA3 protocol adopted is
KECCAK-256) and extract the last 20 bytes of the result. Add 41 to the beginning of the byte array
and ensure the initial address length is 21 bytes. Hash the address twice using SHA3-256 function
and take the first 4 bytes as verification code. Add the verification code to the end of the initial
address and obtain the address in base58check format through base58 encoding. An encoded
Mainnet address begins with T and is 34 bytes in length.

The three different account types are Normal, AssetIssue, and Contract. An Account contains 7
parameters.
A block typically contains a block header and several transactions.
A block header contains ​raw_data​, witness_signature​, and ​blockID​.
Raw data is denoted as ​raw_data​ in Protobuf. It contains the raw data of a message, containing 6
parameters.
Witness signature is denoted as ​witness_signature​ in Protobuf, which is the signature for this
block header from the witness node.
Block ID is denoted as ​blockID​ in Protobuf. It contains the atomic identification of a block. A Block
ID contains 2 parameters:
TRON’s transaction signing process follows a standard ECDSA cryptographic algorithm, with a
SECP256K1 selection curve. A private key is a random number, and the public key is a point on the
elliptic curve. The public key generation process consists of first generating a random number as a
private key, and then multiplying the base point of the elliptic curve by the private key to obtain the public key. When a transaction occurs, the transaction raw data is first converted into byte format.
The raw data then undergoes SHA-256 hashing. The private key corresponding to the contract
address then signs the result of the SHA256 hash. The signature result is then added to the
transaction.
Ordinary transactions only consume bandwidth points, but smart contract operations consume both
energy and bandwidth points. There are two types of bandwidth points available. Users can gain
bandwidth points from freezing TRX, while 5000 free bandwidth points are also available daily.
When a TRX transaction is broadcast, it is transmitted and stored in the form of a byte array over
the network. Bandwidth Points consumed by one transaction = number of transaction bytes
multiplied by bandwidth points rate. For example, if the byte array length of a transaction is 200,
then the transaction consumes 200 bandwidth points. However, if a TRX or token transfer results in
the target account being created, then only the bandwidth points consumed to create the account
will be deducted, and additional bandwidth points will not be deducted. In an account creation
scenario, the network will first consume the bandwidth points that the transaction initiator gained
from freezing TRX. If this amount is insufficient, then the network consumes the transaction
initiator’s TRX.
In standard TRX transfer scenarios from one TRX account to another, the network first consumes
the bandwidth points gained by the transaction initiator for freezing TRX. If that is insufficient, it then
consumes from the free 5000 daily bandwidth points. If that is still not enough, then the network
consumes the TRX of the transaction initiator. The amount is calculated by the number of bytes in
the transaction multiplied by 10 SUN. Thus, for most TRX holders who may not necessarily freeze
their TRX to participate in SR voting, the first step is automatically skipped (since TRX balance
frozen = 0) and the 5000 daily free bandwidth powers the transaction.
For TRC-10 token transfers, the network first verifies whether the total free bandwidth points of the
issued token asset are sufficient. If not, the bandwidth points obtained from freezing TRX are
consumed. If there is still not enough bandwidth points, then it consumes the TRX of the transaction
initiator.
TRON network generally does not charge fees for most transactions, however, due to system
restrictions and fairness, bandwidth usage and transactions do take in certain fees.
Fee charges are broken down into the following categories.
 Normal transactions cost bandwidth points. Users can use the free daily bandwidth points
(5000) or freeze TRX to obtain more. When bandwidth points are not enough, TRX will be
used directly from the sending account. The TRX needed is the number of bytes * 10 SUN.
Smart contracts cost energy (Section 6) but will also need bandwidth points for the
transaction to be broadcasted and confirmed. The bandwidth cost is the same as above.
All query transactions are free. It doesn’t cost energy or bandwidth.
TRON network also defines a set of fixed fees for the following transactions.
TRON uses TaPoS to ensure the transactions all confirm the main blockchain, while making it
difficult to forge counterfeit chains. In TaPoS, the networks require each transaction include part of
the hash of a recent block header. This requirement prevents transactions from being replayed on
forks not including the referenced block, and also signals the network that a particular user and their stake are on a specific fork. This consensus mechanism protects the network against Denial of
Service, 51%, selfish mining, and double spend attacks.
A transaction is included in a future block after being broadcast to the network. After 19 blocks are
mined on TRON (including its own block), the transaction is confirmed. Each block is produced by
one of the top 27 Super Representatives in a round robin fashion. Each block takes ~3 seconds to
be mined on the blockchain. Time may slightly vary for each Super Representative due to network
conditions and machine configurations. In general, a transaction is considered fully confirmed after
~1 minute.
Transaction APIs consist of the following functions.
TRON Virtual Machine (TVM) is a lightweight, Turing complete virtual machine developed for the
TRON's ecosystem. Its goal is to provide a custom-built blockchain system that is efficient,
convenient, stable, secure and scalable.
TVM initially forked from EVM11 and can connect seamlessly with the existing solidity smart contract
development ecosystem. Based on that, TVM additionally supports DPoS consensus.
TVM employs the concept of Energy. Different from the Gas mechanism on EVM, operations of
transactions and smart contracts on TVM are free, with no TRX consumed. Technically, executable
computation capacity on TVM is not restricted by total holding amount of tokens.
The compiler first translates the Solidity smart contract into bytecode readable and executable on
the TVM. The TVM then processes data through opcode, which is equivalent to operating the logic
of a stack-based finite state machine. Finally, the TVM accesses blockchain data and invokes
External Data Interface through the Interoperation layer.
TVM adopts a lightweight architecture with the aim of reducing resource consumption to guarantee
system performance.
TRX transfers and smart contract execution cost bandwidth points only, instead of TRX, which
exempts TRON from being attacked. Bandwidth consumption is predictable and static since each
computational step cost is fixed.
TVM is compatible with EVM and will be compatible with more mainstream VMs in the future.
Thereby, all smart contracts on EVM are executable on TVM.
Due to TVM’s bandwidth setup, development costs are reduced and developers can focus on the
logic development of their contract code. TVM also offers all-in-one interfaces for contract
deployment, triggering and viewing to offer the convenience for developers.
A smart contract is a protocol that digitally verifies contract negotiation. They define the rules and
penalties related to an agreement and also automatically enforce those obligations. The smart
contract code facilitates, verifies, and enforces the negotiation or performance of an agreement or
transaction. From a tokenization perspective, smart contracts also facilitate automatic funds
transfers between participating parties should certain criteria be met.
TRON smart contracts are written in the Solidity language. Once written and tested, they can be
compiled into bytecode, then deployed onto the TRON network for the TRON Virtual Machine. Once
deployed, smart contracts can be queried via their contract addresses. The contract Application
Binary Interface (ABI) shows the contract’s call functions and is used for interacting with the
network.
There are two consumption scenarios to calculate for maximum energy limit for deployment and
trigger. 
When a TRON solidity smart contract is compiled, the TRON Virtual Machine reads the compiled
bytecode. The bytecode consists of a section for code deployment, contract code, and the Auxdata.
The Auxdata is the source code’s cryptographic fingerprint, used for verification. The deployment
bytecode runs the constructor function and sets up the initial storage variables. The deployment
code also calculates the contract code and returns it to the TVM. The ABI is a JSON file that
describes a TRON smart contract’s functions. This file defines the function names, their payability,
the function return values, and their state mutability.

Once the TRON smart contracts are deployed, their functions can be triggered individually either via
TronStudio or through API calls. State-changing functions require Energy while read-only functions
execute without Energy.

TRON Solidity is a fork from Ethereum’s Solidity language. TRON modifies the original project to
support TRX and SUN units (1 TRX = 1,000,000 SUN). The rest of the language syntax is
compatible with Solidity ^0.4.24. Thus the Tron Virtual Machine (TVM) is almost 100% compatible
with EVM instructions.

In the TRON network, each account can issue tokens at the expense of 1024 TRX. ​To issue tokens,
the issuer needs to specify a token name, the total capitalization, the exchange rate to TRX,
circulation duration, description, website, maximum bandwidth consumption per account, total
bandwidth consumption, and the amount of token frozen. Each token issuance can also configure
each account’s maximum daily token transfer Bandwidth Points, the entire network’s maximum daily
token transfer Bandwidth Points, total token supply, locking duration in days, and the total amount
of tokens locked.

TRC-20 is a technical standard used for smart contracts implementing tokens supported by the
TRON Virtual Machine. It is fully compatible with ERC-20.
From a developer’s perspective, there are several differences between TRC-10 and TRC-20. Some
of the key differences are that TRC-10 tokens are accessible by APIs and smart contracts while
TRC-20 tokens allow for interface customization but are only accessible within smart contracts.
From a cost perspective, TRC-10 tokens have transaction fees that are 1000 times lower than
TRC-20, but carry bandwidth costs for API transfers and deposits. Transfers and deposits in smart
contracts for TRC-10 tokens cost both bandwidth and energy.
Since TRON uses the same Solidity version as Ethereum, more token standards could be readily
ported to TRON.
Every account in the TRON network can apply and have the opportunity to become a Super
Representative (denoted as SR). Everyone can vote for SR candidates. The top 27 candidates with
the most votes will become SRs with the right and obligation to generate blocks. The votes are
counted every 6 hours and the SRs will change accordingly.
To prevent malicious attacks, there is a cost to becoming an SR candidate. When applying, 9999
TRX will be burned from the applicant’s account. Once successful, such account can join the SR
election.
TRON Power (denoted as TP) is needed to vote and the amount of TP depends on the voter’s
frozen assets (TRX).
Every account in the TRON network has the right to vote for their own SRs.
After the release (unfreeze, available after 3 days), users won't have any frozen assets and lose all
TP accordingly. As a result, all votes become invalid for the ongoing and future voting round unless
TRX is frozen again to vote.
Note that the TRON network only records the most recent vote, which means that every new vote
will negate all previous votes.
Also known as Candidate Reward, which the top 127 candidates updated once every round (6
hours) will share 115,200 TRX as mined. The reward will be split in accordance with the vote weight
each candidate receives. Each year, the total reward for candidates will be 168,192,000 TRX.
Total vote reward per round
Also known as Super Representative Reward, which the top 27 candidates (SRs) who are elected
every round (6 hours) will share roughly 230,400 TRX as mined. The reward will be split evenly
between the 27 SRs (minus the total reward blocks missed due to network error). A total of
336,384,000 TRX will be awarded annually to the 27 SRs.
The committee is used to modify TRON dynamic network parameters, such as block generation
rewards, transaction fees, etc. The committee consists of the 27 SRs in the current round. Each SR
has the right to propose and vote on proposals. When a proposal receives 19 votes or more, it is
approved and the new network parameters will be applied in the next maintenance period (3 days).
Only the SR accounts have the rights to propose a change in dynamic network parameters.
Only committee members (SRs) can vote for a proposal and the member who does not vote in time
will be considered as a disagree. The proposal is active for 3 days after it is created. The vote can
be changed or retrieved during the 3-days voting window. Once the period ends, the proposal will
either succeed (19+ votes) or fail (and end).
The proposer can cancel the proposal before it becomes effective.
SRs are the witnesses of newly generated blocks. A witness contains 8 parameters. The TRON network offers a wide selection of over 60+ HTTP API gateways for interacting with the
network via Full and Solidity Nodes. Additionally, TronWeb is a comprehensive JavaScript library
containing API functions that enable developers to deploy smart contracts, change the blockchain
state, query blockchain and contract information, trade on the DEX, and much more. These API
gateways can be directed towards a local privatenet, the Shasta testnet, or the TRON Mainnet.
TRON has both a Shasta testnet as well as a Mainnet. Developers may connect to the networks by
deploying nodes, interacting via TronStudio, or using APIs via the TronGrid service. The TronGrid
service consists of load balanced node clusters hosted on AWS servers worldwide. As DApp
development scales up and API call volumes increase, TronGrid successfully fields the increase in
API traffic.
TRON offers a suite of development tools for enabling developers to create innovative DApps.
TronBox is a framework that allows developers to test and deploy smart contracts via the TronWeb
API. TronGrid is a load balanced and hosted API service that allows developers to access the
TRON network without having to run their own node. TronGrid offers access to both the Shasta
testnet as well as the TRON Mainnet. TronStudio is a comprehensive Integrated Development
Environment (IDE) that enables developers to compile, deploy, and debug their Solidity smart
contracts. TronStudio contains an internal full node that creates a private local environment for
smart contract testing prior to deployment. The TronWeb API library connects developers to the
network via a wide selection of HTTP API calls wrapped in JavaScript.
The TRON Developer Hub is a comprehensive API documentation12 site tailored towards
developers wishing to build on the TRON network. The Developer Hub provides a high-level
conceptual understanding of TRON and walks users through the details of interacting with the
network. The guides walk developers through node setup, deployment and interaction with smart
contracts, API interaction and implementation, building sample DApps, and using each of the
developer tools. Additionally, developer community channels are available through Discord13.
TRON is a scalable blockchain solution that has employed innovative methods for tackling
challenges faced by legacy blockchain networks. Having reached over 2M transactions per day,
with over 700K TRX accounts, and surpassing 2000 TPS, TRON has enabled the community in
creating a decentralized and democratized network.